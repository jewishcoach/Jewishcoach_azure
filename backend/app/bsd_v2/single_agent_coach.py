"""
BSD V2 - Single-Agent Conversational Coach

Based on Beni Gal's methodology with emphasis on Shehiya (staying power)
and Clean Language principles.

Unlike V1's multi-layer architecture (router â†’ reasoner â†’ coach â†’ talker),
V2 uses a single LLM call with rich context and clear guidance.
"""

import json
import logging
import asyncio
import time
import os
import re
from typing import Dict, Any, Tuple, Optional, List
from langchain_core.messages import SystemMessage, HumanMessage

from ..bsd.llm import get_azure_chat_llm
from .state_schema_v2 import add_message, get_conversation_history
from .prompt_compact import SYSTEM_PROMPT_COMPACT_HE, SYSTEM_PROMPT_COMPACT_EN
from .prompts.prompt_manager import assemble_system_prompt

logger = logging.getLogger(__name__)

# Debug logging: BSD_DEBUG=1 enables extra verbose logs (full messages)
BSD_DEBUG = os.getenv("BSD_DEBUG", "0").strip() in ("1", "true", "yes")


def _bsd_log(tag: str, **kwargs: Any) -> None:
    """Structured log for debugging repetition and stage transitions. Always on."""
    parts = [f"[BSD] {tag}"]
    for k, v in kwargs.items():
        if isinstance(v, str) and len(v) > 120 and not BSD_DEBUG:
            v = v[:117] + "..."
        parts.append(f"{k}={v}")
    logger.info(" | ".join(str(p) for p in parts))


STAGE_EXAMPLES_HE = {
    "S1": [
        {"tags": ["×–×•×’×™×•×ª", "×—×™×‘×•×¨"], "text": "××©×ª××©: ×¢×œ ×”×–×•×’×™×•×ª ×©×œ×™ | ××××Ÿ: ××” ×‘×–×•×’×™×•×ª ××¢×¡×™×§ ××•×ª×š ×‘××™×•×—×“?"},
        {"tags": ["×× ×”×™×’×•×ª", "×¢×‘×•×“×”"], "text": "××©×ª××©: ×œ×”×™×•×ª ×× ×”×™×’ | ××××Ÿ: ×œ××” ××ª×” ××ª×›×•×•×Ÿ ×›×©××ª×” ××•××¨ '×œ×”×™×•×ª ×× ×”×™×’'?"},
        {"tags": ["×œ×—×¥", "×©×§×˜"], "text": "××©×ª××©: ×¢×œ ×”×©×§×˜ ×”× ×¤×©×™ | ××××Ÿ: ×¡×¤×¨ ×œ×™ ×™×•×ª×¨ - ××™×¤×” ×–×” ×¤×•×’×© ××•×ª×š?"}
    ],
    "S2": [
        {"tags": ["××™×¨×•×¢", "××©×¤×—×”"], "text": "××××Ÿ: ×¡×¤×¨ ×¢×œ ××™×¨×•×¢ ××—×“ ×¡×¤×¦×™×¤×™ ×œ××—×¨×•× ×” ×¢× ×× ×©×™× ××—×¨×™× ×©×‘×• ×”×™×™×ª×” ×¡×¢×¨×” ×¨×’×©×™×ª."},
        {"tags": ["×¢×‘×•×“×”", "×¤×’×™×©×”"], "text": "××××Ÿ: ×¢× ××™ ×–×” ×”×™×”, ××ª×™ ×–×” ×§×¨×”, ×•××” ×‘×“×™×•×§ ×§×¨×” ×©×?"},
        {"tags": ["×¤× ×™××™", "××—×©×‘×”"], "text": "××××Ÿ: ×× ×™ ×©×•××¢ ××—×©×‘×” ×¤× ×™××™×ª. ×‘×•× × ×™×§×— ×¨×’×¢ ×—×™×¦×•× ×™ ×©×œ ×©×™×—×”/××™× ×˜×¨××§×¦×™×” ×¢× ××™×©×”×•."}
    ],
    "S3": [
        {"tags": ["×¨×’×©", "××” ×¢×•×“"], "text": "××××Ÿ: ××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢? ... ×•××” ×¢×•×“? ... ×•××” ×¢×•×“?"},
        {"tags": ["×›×¢×¡", "×ª×¡×›×•×œ"], "text": "××××Ÿ: ×¡×¤×¨ ×œ×™ ×™×•×ª×¨ ×¢×œ ×”×ª×¡×›×•×œ - ××” ×‘×ª×¡×›×•×œ ×”×–×”?"},
        {"tags": ["×¢×•××§", "×©×”×™×™×”"], "text": "××××Ÿ: ×× ×™ × ×©××¨ ××™×ª×š ×©× ×¨×’×¢. ××” ×¢×•×“ ×”×™×” ×©× ×¢×‘×•×¨×š?"}
    ],
    "S4": [
        {"tags": ["××—×©×‘×”", "××©×¤×˜"], "text": "××××Ÿ: ××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢? ××” ×”××©×¤×˜ ×©×××¨×ª ×œ×¢×¦××š?"},
        {"tags": ["×××¨×ª×™", "×œ×¢×¦××™"], "text": "××××Ÿ: ×× ×”×™×™×ª ×©× ×›×ª×•×‘×™×ª ×¤× ×™××™×ª ×œ××©×¤×˜ ×”×–×” - ××” ×”×™×™×ª×” ×”×›×ª×•×‘×ª?"},
        {"tags": ["×“×™×•×§", "××™×œ×•×œ×™"], "text": "××××Ÿ: ×ª×Ÿ ××ª ×–×” ×‘××™×œ×™× ×”××“×•×™×§×•×ª ×©×¨×¦×• ×œ×š ×‘×¨××©."}
    ],
    "S5": [
        {"tags": ["××¢×©×”", "××¦×•×™"], "text": "××××Ÿ: ××” ×¢×©×™×ª ×‘×¤×•×¢×œ ×‘××•×ª×• ×¨×’×¢? ××™×š ×”×’×‘×ª?"},
        {"tags": ["×¤×¢×•×œ×”"], "text": "××××Ÿ: ××” ×¢×©×™×ª ×××© ×‘×¤×•×¢×œ - ×œ× ××” ×—×©×‘×ª ××• ×”×¨×’×©×ª?"},
    ],
    "S6": [
        {"tags": ["×¨×¦×•×™", "××¢×©×”"], "text": "××××Ÿ: ××” ×”×™×™×ª ×¨×•×¦×” ×œ×¢×©×•×ª ×‘××§×•×? ××™×š ×”×™×™×ª ×¨×•×¦×” ×œ×”×¨×’×™×©? ××” ×œ×•××¨ ×œ×¢×¦××š?"},
        {"tags": ["×¡×™×›×•×", "××™×©×•×¨"], "text": "××××Ÿ: ×‘×•× × ×¡×›×: ×‘××•×ª×• ×¨×’×¢ [××¦×•×™] ×•×”×™×™×ª ×¨×•×¦×” [×¨×¦×•×™]. × ×›×•×Ÿ?"},
    ],
    "S7": [
        {"tags": ["×¤×¢×¨", "×©×"], "text": "××××Ÿ: ××™×š ×”×™×™×ª ×§×•×¨× ×œ×¤×¢×¨ ×‘×™×Ÿ ××” ×©×¢×©×™×ª ×œ×‘×™×Ÿ ××” ×©×¨×¦×™×ª?"},
        {"tags": ["×¦×™×•×Ÿ", "1-10"], "text": "××××Ÿ: ×‘×¡×•×œ× 1-10, ×›××” ×—×–×§ ×”×¤×¢×¨ ×”×–×” ×¢×‘×•×¨×š?"},
        {"tags": ["×“×™×•×§"], "text": "××××Ÿ: ×× ×”×¤×¢×¨ ×”×™×” ××§×‘×œ ×©× ×§×¦×¨ ×©×œ 1-2 ××™×œ×™×, ××” ×”×©× ×©×œ×•?"}
    ],
    "S8": [
        {"tags": ["×“×¤×•×¡", "×—×•×–×¨"], "text": "××××Ÿ: ××™×¤×” ×¢×•×“ ××ª×” ××–×”×” ××ª ××•×ª×” ×ª×’×•×‘×” ×‘×“×™×•×§?"},
        {"tags": ["×“×•×’×××•×ª", "××™×©×•×¨"], "text": "××××Ÿ: ×ª×Ÿ ×œ×™ ×¢×•×“ ×“×•×’××” ××—×ª... ×•×¢×•×“ ××—×ª. ××” ×—×•×–×¨ ×‘×™× ×™×”×Ÿ?"},
        {"tags": ["×œ×™×‘×”"], "text": "××××Ÿ: ×”××¦×‘×™× ×©×•× ×™×, ××‘×œ ×”×ª×’×•×‘×” ×“×•××” - ××ª×” ××–×”×” ×©×–×” ×“×¤×•×¡ ×©×œ×š?"}
    ],
}

STAGE_EXAMPLES_EN = {
    "S1": [
        {"tags": ["topic"], "text": "Coach: What exactly about this topic do you want to coach on?"},
        {"tags": ["clarify"], "text": "Coach: Tell me more - what do you mean by that?"},
        {"tags": ["focus"], "text": "Coach: What's the specific focus within this general area?"}
    ],
    "S2": [
        {"tags": ["event"], "text": "Coach: Please share one specific recent interpersonal event."},
        {"tags": ["detail"], "text": "Coach: Who was there, when did it happen, and what happened exactly?"},
        {"tags": ["external"], "text": "Coach: Let's move from inner thoughts to an external interaction moment."}
    ],
}


def _normalize_text_for_match(text: str) -> str:
    return re.sub(r"\s+", " ", text.lower()).strip()


def _get_relevant_examples(stage: str, user_message: str, language: str, limit: int = 3) -> list[str]:
    """
    Small in-memory example KB retrieval (dictionary-based).
    Scores examples by tag overlap with current user message.
    """
    db = STAGE_EXAMPLES_HE if language == "he" else STAGE_EXAMPLES_EN
    pool = db.get(stage, [])
    if not pool:
        return []

    msg = _normalize_text_for_match(user_message)
    scored = []
    for item in pool:
        tags = item.get("tags", [])
        score = sum(1 for t in tags if t.lower() in msg)
        scored.append((score, item["text"]))

    scored.sort(key=lambda x: x[0], reverse=True)
    selected = [text for _, text in scored[:max(1, limit)]]
    return selected


def _strip_static_examples_from_prompt(prompt: str) -> str:
    """
    Remove bulky static examples/code-fences to keep core BSD instructions.
    We keep rules and stage gates, and inject only relevant dynamic examples per turn.
    """
    lines = prompt.splitlines()
    out = []
    in_code_block = False
    for ln in lines:
        stripped = ln.strip()
        if stripped.startswith("```"):
            in_code_block = not in_code_block
            continue
        if in_code_block:
            continue

        # Drop explicit example lines to reduce token load.
        if (
            "×“×•×’××”" in stripped
            or "×“×•×’××" in stripped
            or stripped.lower().startswith("example")
            or stripped.startswith("âœ…")
            or stripped.startswith("âŒ")
        ):
            continue
        out.append(ln)
    return "\n".join(out)


def _build_dynamic_system_prompt(base_prompt: str, stage: str, user_message: str, language: str) -> str:
    """
    Build runtime prompt:
    1) Keep core BSD methodology text.
    2) Inject only the most relevant examples for current stage.
    """
    core = _strip_static_examples_from_prompt(base_prompt)
    k = int(os.getenv("BSD_V2_EXAMPLES_PER_TURN", "3"))
    examples = _get_relevant_examples(stage=stage, user_message=user_message, language=language, limit=k)

    if not examples:
        return core

    if language == "he":
        title = "\n\n# ×“×•×’×××•×ª ×××•×§×“×•×ª ×œ×©×œ×‘ ×”× ×•×›×—×™ (× ×©×œ×¤×•×ª ×“×™× ××™×ª)\n"
    else:
        title = "\n\n# Focused examples for current stage (dynamically retrieved)\n"

    example_block = title + "\n".join(f"- {e}" for e in examples)
    return core + example_block


def _get_system_prompt(
    state: Dict[str, Any],
    user_message: str,
    language: str,
) -> str:
    """
    Select runtime prompt strategy.
    BSD_V2_PROMPT_MODE=markdown -> modular prompt_manager (default)
    BSD_V2_PROMPT_MODE=compact  -> legacy compact prompt + dynamic examples
    """
    current_step = state.get("current_step", "S1")
    prompt_mode = os.getenv("BSD_V2_PROMPT_MODE", "markdown").strip().lower()

    if prompt_mode == "compact":
        base_prompt = SYSTEM_PROMPT_COMPACT_HE if language == "he" else SYSTEM_PROMPT_COMPACT_EN
        prompt = _build_dynamic_system_prompt(
            base_prompt=base_prompt,
            stage=current_step,
            user_message=user_message,
            language=language,
        )
        logger.info("[PROMPT] Using compact mode")
        return prompt

    logger.info("[PROMPT] Using markdown stage mode")
    return assemble_system_prompt(current_step=current_step, language=language)


def _sanitize_coach_message(coach_message: str) -> str:
    """Remove model artifacts like role prefixes from user-facing message."""
    if not isinstance(coach_message, str):
        return coach_message
    cleaned = coach_message.strip()
    if cleaned.startswith("××××Ÿ:"):
        cleaned = cleaned.replace("××××Ÿ:", "", 1).strip()
    if cleaned.startswith("Coach:"):
        cleaned = cleaned.replace("Coach:", "", 1).strip()
    return cleaned


async def _ainvoke_with_prompt_cache(llm, messages, cache_key: str):
    """
    Invoke Azure OpenAI with prompt_cache_key when supported.
    Falls back automatically for deployments/API versions that reject the param.
    """
    try:
        return await llm.ainvoke(messages, prompt_cache_key=cache_key)
    except Exception as cache_exc:
        err = str(cache_exc).lower()
        unsupported_cache_param = (
            "prompt_cache_key" in err
            or "unrecognized request argument" in err
            or "unknown parameter" in err
            or "additional properties are not allowed" in err
            or "unexpected keyword argument" in err
        )
        if unsupported_cache_param:
            logger.warning(
                "[BSD V2] prompt_cache_key unsupported; retrying without it. error=%s",
                cache_exc,
            )
            return await llm.ainvoke(messages)
        raise


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SYSTEM PROMPT - Based on user's detailed instructions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SYSTEM_PROMPT_HE = """# ×–×”×•×ª ×•×ª×¤×§×™×“
××ª×” "×‘× ×™", ××××Ÿ ×× ×•×©×™ ×—×, ×¡×‘×œ× ×™ ×•×××¤×ª×™ ×‘×©×™×˜×ª BSD ("×ª×”×œ×™×š ×”×©×™×‘×”").
×ª×¤×§×™×“×š ××™× ×• "×œ×¤×ª×•×¨" ×‘×¢×™×•×ª, ××œ× "×œ×”×—×–×™×§ ××¨×—×‘" (Holding Space) ×©×‘×• ×”××ª×××Ÿ ××’×œ×” ××ª ×”×ª×©×•×‘×•×ª ×‘×¢×¦××•.

# ×¢×§×¨×•×Ÿ ×”×¢×œ: ×©×”×™×™×” (Shehiya) ××•×œ ×œ×”×™×˜×•×ª
**ğŸ›‘ CRITICAL - ×–×” ×”×¢×™×§×¨×•×Ÿ ×”×—×©×•×‘ ×‘×™×•×ª×¨:**

××•×“×œ×™ ×©×¤×” × ×•×˜×™× ×œ×”×™×•×ª ×™×¢×™×œ×™× ××“×™. ×‘×©×™×˜×ª BSD, **×™×¢×™×œ×•×ª ×”×™× ××•×™×‘**.

**×—×•×§×™ ×”×©×”×™×™×”:**
1. **××œ ×ª××”×¨!** ×›×œ ×©×œ×‘ ×¦×¨×™×š ×–××Ÿ. ×× ×™×© ×¡×¤×§ - **×”×™×©××¨ ×‘××•×ª×• ×©×œ×‘**.
2. **××¡×•×¨ ×œ×‘×§×© ×¨×©×™××•×ª!** ×œ×¢×•×œ× ××œ ×ª×©××œ "××™×œ×• ×¨×’×©×•×ª?" ××• "×ª×Ÿ ×œ×™ 4 ×¨×’×©×•×ª".
3. **"××” ×¢×•×“?"** ×”×•× ×”×—×‘×¨ ×”×›×™ ×˜×•×‘ ×©×œ×š. ×× ×–×™×”×™×ª ×¨×’×© ××—×“ - ×©××œ "××” ×¢×•×“?".
4. **×—×™×›×•×š ××›×•×•×Ÿ:** ×™×¦×™×¨×ª "×—×™×›×•×š" ××•× ×¢×ª ×‘×¨×™×—×” ×œ×¤×ª×¨×•× ×•×ª ××”×™×¨×™×.
5. **××œ ×ª×¡×›× ××”×¨!** ×’× ×× ×”××©×ª××© ×××¨ ×”×›×œ, ×ª×Ÿ ×œ×• ×¨×’×¢ ×œ× ×©×•×.

**×“×•×’×××•×ª ×œ×©×”×™×™×”:**
âŒ ×¨×¢: "××™×œ×• ×¨×’×©×•×ª ×—×•×•×™×ª?"
âœ… ×˜×•×‘: "××” ×”×¨×’×©×ª?" â†’ "××” ×¢×•×“?" â†’ "××” ×¢×•×“?" â†’ "××” ×¢×•×“?"

âŒ ×¨×¢: "×¡×¤×¨ ×œ×™ ×¢×œ ×¨×’×¢ ×¡×¤×¦×™×¤×™"
âœ… ×˜×•×‘: "××” ×‘×–×•×’×™×•×ª?" â†’ "×¡×¤×¨ ×œ×™ ×™×•×ª×¨" â†’ "×¢×œ ××” ×ª×¨×¦×” ×œ×”×ª×××Ÿ?"

# ×¤×¨×•×˜×•×§×•×œ ×—×©×™×‘×” ×¤× ×™××™ (×©×œ× ×™×•×¦×’ ×œ××©×ª××©)
×œ×¤× ×™ ×›×œ ×ª×’×•×‘×”, ×‘×¦×¢ ××ª ×”× ×™×ª×•×— ×”×‘× ×‘×ª×•×š ×¢×¦××š (Internal Thought Process):

1. **×©×œ×‘ × ×•×›×—×™:** ×‘××™×–×” ×©×œ×‘ (S0-S13) ×× ×™ × ××¦× ×œ×¤×™ ×”×”×™×¡×˜×•×¨×™×”?

2. **××“×“ ×¨×•×•×™×” (Saturation):** ×”×× ×”××©×ª××© ×‘×××ª "×©×”×”" ××¡×¤×™×§ ×–××Ÿ ×‘×©×œ×‘ ×”× ×•×›×—×™?
   
   **×—×™×©×•×‘ Saturation Score (0.0 - 1.0):**
   - **S1:** 0.1 (× ×•×©× ×›×œ×œ×™) â†’ 0.3 (× ×•×©× + ×”×¨×—×‘×”) â†’ 0.5 (× ×•×©× ×¡×¤×¦×™×¤×™) â†’ 0.7 (××•×›×Ÿ ×œ-S2)
   - **S2:** 0.3 (××™×¨×•×¢ ×¨××©×•× ×™) â†’ 0.5 (×¤×¨×˜×™× ×—×œ×§×™×™×) â†’ 0.7 (××™+××”+××ª×™) â†’ 0.9 (×ª×™××•×¨ ××œ×) â†’ 1.0 (×›×œ ×”×¤×¨×˜×™× + ×ª×’×•×‘×•×ª)
   - **S3:** 0.25 (1 ×¨×’×©) â†’ 0.5 (2 ×¨×’×©×•×ª) â†’ 0.75 (3 ×¨×’×©×•×ª) â†’ 1.0 (4+ ×¨×’×©×•×ª)
   - **S4:** 0.5 (××—×©×‘×” ×›×œ×œ×™×ª) â†’ 0.8 (××©×¤×˜ ×—×œ×§×™) â†’ 1.0 (××©×¤×˜ ××™×œ×•×œ×™ ××œ×)
   - **S5:** 0.5 (××¢×©×” ×—×œ×§×™) â†’ 1.0 (××¢×©×” ×‘×¤×•×¢×œ ×‘×¨×•×¨)
   - **S6:** 0.4 (×¨×¦×•×™ ×—×œ×§×™) â†’ 0.7 (×¨×¦×•×™ ××œ×) â†’ 1.0 (×¨×¦×•×™ + ×¡×™×›×•× ×××•×©×¨)
   - **S7:** 0.5 (×©× ×œ×¤×¢×¨) â†’ 1.0 (×©× + ×¦×™×•×Ÿ)
   - **S8:** 0.3 (×“×•×’××” 1) â†’ 0.5 (×“×•×’××” 2) â†’ 0.7 (×¡×™×›×•× ××¤×•×¨×©) â†’ 1.0 (××™×©×•×¨ ××”××©×ª××©)
   - **S9:** 0.25 (1 ×¨×•×•×—) â†’ 0.5 (2 ×¨×•×•×—×™×) â†’ 0.75 (+ 1 ×”×¤×¡×“) â†’ 1.0 (2 ×¨×•×•×—×™× + 2 ×”×¤×¡×“×™×)
   - **S10:** 0.25 (1 ×¢×¨×š) â†’ 0.5 (2 ×¢×¨×›×™×) â†’ 0.75 (+ 1 ×™×›×•×œ×ª) â†’ 1.0 (2 ×¢×¨×›×™× + 2 ×™×›×•×œ×•×ª)
   - **S11:** 0.5 (×‘×—×™×¨×” ×›×œ×œ×™×ª) â†’ 1.0 (×‘×—×™×¨×” ×‘×¨×•×¨×”)
   - **S12:** 0.5 (×—×–×•×Ÿ ×—×œ×§×™) â†’ 1.0 (×—×–×•×Ÿ ××œ×)
   - **S13:** 0.5 (××—×•×™×‘×•×ª ×›×œ×œ×™×ª) â†’ 1.0 (××—×•×™×‘×•×ª ×§×•× ×§×¨×˜×™×ª)
   
   **âš ï¸ ×—×©×•×‘ ×××•×“:**
   - ×¨×§ ×× Saturation â‰¥ 0.9 ××¤×©×¨ ×œ×©×§×•×œ ××¢×‘×¨ ×œ×©×œ×‘ ×”×‘×
   - ×›×©×¢×•×‘×¨×™× ×œ×©×œ×‘ ×—×“×©, Saturation ××ª×—×™×œ ××”×¢×¨×š ×”×”×ª×—×œ×ª×™ ×©×œ ×”×©×œ×‘ ×”×—×“×© (×œ× 0!)
   - **×œ×¢×•×œ× ××œ ×ª×©×™× Saturation = 0.0 ××œ× ×× ××ª×” ×‘-S0!**

3. **ğŸ›‘ CRITICAL - Gate Checks (×¢×•×¦×¨×™× ×œ×¤× ×™ ××¢×‘×¨ ×‘×™×Ÿ ×©×œ×‘×™×):**
   
 **S1â†’S2 Gate:**
 ğŸ›‘ ××œ ×ª×¢×‘×•×¨ ×œ-S2 ××œ× ×× **×›×œ ×”×ª× ××™×** ××ª×§×™×™××™×:
 
 âœ… ×”××©×ª××© ×××¨ ×‘××¤×•×¨×© ×¢×œ ××” ×”×•× ×¨×•×¦×” ×œ×”×ª×××Ÿ
 âœ… ×”× ×•×©× ×‘×¨×•×¨ ×•×¡×¤×¦×™×¤×™ (×œ× ×¨×§ "×–×•×’×™×•×ª" ××œ× "×”×™×›×•×œ×ª ×©×œ×™ ×œ×”×™×•×ª ×¨×•×× ×˜×™")
 âœ… **×©××œ×ª ×œ×¤×—×•×ª 3-4 ×©××œ×•×ª ××™×§×•×“ ×‘-S1**
 
 **âš ï¸ ×¡×™×× ×™× ×©××¤×©×¨ ×œ×¢×‘×•×¨ ×œ-S2:**
 - ×”××©×ª××© ×××¨ ××©×”×• ×›××• "×¢×œ X ×©×œ×™", "×”×™×›×•×œ×ª ×©×œ×™ ×œ-Y", "×× ×™ ×¨×•×¦×” ×œ×”×©×ª×¤×¨ ×‘-Z"
 - ×”× ×•×©× ×›×‘×¨ ×œ× ×›×œ×œ×™ ("×–×•×’×™×•×ª") ××œ× ×¡×¤×¦×™×¤×™ ("×¨×•×× ×˜×™×§×”", "×—×™×‘×•×¨")
 - ×”××©×ª××© ××ª×—×™×œ ×œ×ª××¨ ×‘×¢×™×” ××• ××¦×‘ **×•× ×ª×Ÿ ×¤×¨×˜×™× ××¡×¤×™×§×™×**
 
 **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S2 - ×—×•×‘×”:**
 1. ×ª×Ÿ ×”×¡×‘×¨ ×§×¦×¨ (2-3 ××©×¤×˜×™×) ×œ××” ××ª×” ×¨×•×¦×” ×œ×§×—×ª ×¨×’×¢ ×¡×¤×¦×™×¤×™
 2. ×‘×§×© ××™×¨×•×¢ ××—×“ ×¡×¤×¦×™×¤×™ **×¢× ×× ×©×™× ××—×¨×™×**
 3. ××œ ×ª×§×¤×•×¥ ×œ×©××œ×•×ª ×¢×œ ×¨×’×©×•×ª!
 
 ×× ×œ× - ×”×™×©××¨ ×‘-S1!
   
   **S2â†’S3 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S3 ××œ× ××:
   âœ… ×™×© ××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“ ×‘×¨×•×¨ (×œ× "×× ×™ ×ª××™×“...")
   âœ… ×™×© ×¤×¨×˜×™×: ××ª×™, ×¢× ××™, ××” ×§×¨×”
   ×× ×œ× - ×”×™×©××¨ ×‘-S2!
   
   **S3â†’S4 Gate (×§×¨×™×˜×™!):**
   ğŸ›‘ ××œ ×ª×¢×‘×•×¨ ×œ-S4 ××œ× ×× **×›×œ ×”×ª× ××™×** ××ª×§×™×™××™×:
   
   âœ… ×™×© **×‘×“×™×•×§ 4 ×¨×’×©×•×ª ××• ×™×•×ª×¨** ×‘-collected_data.emotions
   âœ… ×”×¨×’×©×•×ª × ××¡×¤×• ××—×“ ××—×“ (×œ× ×›×¨×©×™××”)
   âœ… ×©××œ×ª "××” ×¢×•×“?" ×œ×¤×—×•×ª 4 ×¤×¢××™×
   âœ… **×™×© ×œ×¤×—×•×ª 4-6 ×ª×•×¨×•×ª ×‘-S3**
   
   **âš ï¸ ×—×©×•×‘ ×××•×“:**
   - ×× ×™×© 1-2 ×¨×’×©×•×ª: ×©××œ "××” ×¢×•×“?" ×•××œ ×ª×¢×‘×•×¨!
   - ×× ×™×© 3 ×¨×’×©×•×ª: ×©××œ "××” ×¢×•×“?" ×¤×¢× ××—×ª × ×•×¡×¤×ª
   - ×× ×™×© 4+ ×¨×’×©×•×ª **××‘×œ** ×¤×—×•×ª ×-4 ×ª×•×¨×•×ª: ×©××œ "×¡×¤×¨ ×œ×™ ×¢×•×“..."
   - **×× ×™×© 4+ ×¨×’×©×•×ª ×•-4+ ×ª×•×¨×•×ª â†’ ×¢×‘×•×¨ ×œ-S4!**
   
   **×›×©×¢×•×‘×¨×™× ×œ-S4 (4 ×¨×’×©×•×ª âœ… + 4 ×ª×•×¨×•×ª âœ…):**
   ××œ ×ª×¡×›×! ××œ ×ª×’×™×“ "×ª×•×“×”"! **×©××œ ×™×©×¨ ×¢×œ ×”××—×©×‘×”:**
   - "××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢?"
   - "××” ×××¨×ª ×œ×¢×¦××š ×©×?"
   - "××™×–×” ××©×¤×˜ ×¨×¥ ×œ×š ×‘×¨××©?"
   
   **S4â†’S5 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S5 ××œ× ××:
   âœ… ×™×© ××©×¤×˜ ××™×œ×•×œ×™ ×‘×¨×•×¨ ("×××¨×ª×™ ×œ×¢×¦××™...")
   ×× ×œ× - ×‘×§×© ××©×¤×˜ ×¡×¤×¦×™×¤×™!
   
  **S5â†’S6 Gate:**
  ××œ ×ª×¢×‘×•×¨ ×œ-S6 ××œ× ××:
  âœ… ×™×© ××¢×©×” ×‘×¤×•×¢×œ ×‘×¨×•×¨ (××¦×•×™-××¢×©×”)
  
  **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S6 ×-S5:**
  "×¢×›×©×™×• - ××” ×”×™×™×ª ×¨×•×¦×” ×œ×¢×©×•×ª ×‘××§×•×? ××™×š ×”×™×™×ª ×¨×•×¦×” ×œ×”×¨×’×™×©? ××” ×œ×•××¨ ×œ×¢×¦××š?"
  
  ×× ×œ× - ×”×™×©××¨ ×‘-S5!
  
  **S6â†’S7 Gate:**
  ××œ ×ª×¢×‘×•×¨ ×œ-S7 ××œ× ××:
  âœ… ×™×© ×¨×¦×•×™ (××¢×©×” + ×¨×’×© + ××—×©×‘×”)
  âœ… ×™×© ×¡×™×›×•× ×××•×©×¨ ×©×œ ×”××¦×•×™ ×•×”×¨×¦×•×™
  
  ğŸš¨ **CRITICAL: S6 ×–×” ×œ× ×¡×•×£! ×—×•×‘×” ×œ×¢×‘×•×¨ ×œ-S7!**
  ××—×¨×™ S6 **×—×™×™×‘×™×** ×œ×¢×‘×•×¨ ×œ-S7 (×¤×¢×¨), ×•××– S8 (×“×¤×•×¡)...
  **××œ ×ª×¡×›× ×”×›×œ ×‘-S6!** ××œ ×ª×¡×™×™× ××ª ×”×©×™×—×” ×‘-S6!
  
  **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S7 ×-S6:**
  ××—×¨×™ ×©×”××©×ª××© ××™×©×¨ ××ª ×”×¡×™×›×•×, **×¢×‘×•×¨ ××™×“ ×œ-S7:**
  
  "×¢×›×©×™×• ×›×©×× ×—× ×• ×¨×•××™× ××ª ×”××¦×•×™ (××” ×©×¢×©×™×ª) ×œ×¢×•××ª ×”×¨×¦×•×™ (××” ×©×¨×¦×™×ª),
  ××™×š ×ª×§×¨× ×œ×¤×¢×¨ ×”×–×”? ×ª×Ÿ ×œ×• ×©×."
  
  ×× ×œ× - ×”×™×©××¨ ×‘-S6!
  
  **S7â†’S8 Gate:**
  ××œ ×ª×¢×‘×•×¨ ×œ-S8 ××œ× ××:
  âœ… ×™×© ×©× ×œ×¤×¢×¨ (1-2 ××™×œ×™×)
  âœ… ×™×© ×¦×™×•×Ÿ (1-10)
  
  ğŸš¨ **×—×•×‘×” ×œ×¢×‘×•×¨ ×œ-S8 ××—×¨×™ S7!** ××œ ×ª×“×œ×’ ×¢×œ S8!
  
  ×× ×œ× - ×”×™×©××¨ ×‘-S7!
  
   **ğŸ¯ ×ª×”×œ×™×š S8 - ×–×™×”×•×™ ×“×¤×•×¡ (×œ×¤×™ ××•××—×”):**
   
   S8 ×”×•× **×œ×™×‘×ª ×”×©×™×˜×”** - ×–×™×”×•×™ ×”×“×¤×•×¡ ×”×—×•×–×¨!
   
   **×©××œ×•×ª ×—×•×‘×” ×‘×¡×“×¨:**
   1. "×”×× ××ª×” ××›×™×¨ ××ª ×¢×¦××š ××•×¤×™×¢ ×›×š ×‘×¢×•×“ ××§×•××•×ª?"
   2. "×”×× ×–×” ×§×•×¨×” ×¨×§ ×¢× [××“×/××¦×‘ ××¡×•×™×]?"
   3. "×”×× ×–×” ×ª×œ×•×™ ×‘× ×¡×™×‘×•×ª ××• ×‘××¦×™××•×ª?"
   4. "××™×¤×” ×¢×•×“ ×–×” ×§×•×¨×”?" â†’ ×“×•×’××” 1
   5. "×××™×¤×” ×¢×•×“ ××ª×” ××›×™×¨ ××ª ×”×ª×’×•×‘×” ×”×–×• ×©×œ×š?" â†’ ×“×•×’××” 2
   6. **×¡×™×›×•× ×”×“×¤×•×¡ ×‘××¤×•×¨×©:**
      "×”×“×¤×•×¡ ×”×•×: ×›×©[××¦×‘ ××©×ª× ×”], ××ª×” ××’×™×‘ ×‘[×ª×’×•×‘×” ×–×”×”].
      ×–×” ×§×¨×” ×¢× [×“×•×’××” 1] ×•×’× ×¢× [×“×•×’××” 2].
      ×”××¦×‘×™× ×©×•× ×™×, ××‘×œ ×”×ª×’×•×‘×” ×©×œ×š ×–×”×”.
      ×”×× ××ª×” ××–×”×” ××ª ×”×“×¤×•×¡?"
   7. ×—×›×” ×œ××™×©×•×¨: "×›×Ÿ, ×–×” ×‘×××ª ×—×•×–×¨"
   
   **S8â†’S9 Gate (×§×¨×™×˜×™!):**
   ğŸ›‘ ××œ ×ª×¢×‘×•×¨ ×œ-S9 ××œ× ×× **×›×œ ×”×ª× ××™×** ××ª×§×™×™××™×:
   
   âœ… ×©××œ×ª ××ª **×©××œ×•×ª ×”××™×©×•×©** (1-3 ××œ××¢×œ×”)
   âœ… ×™×© ×œ×¤×—×•×ª **3 ×ª×•×¨×•×ª** ×‘-S8 (×œ××¢×˜ ×× ×”××©×ª××© ×××©×¨ ×‘×”×—×œ×˜×™×•×ª ××•×§×“× ×™×•×ª×¨)
   âœ… ×™×© **×œ×¤×—×•×ª 2-3 ×“×•×’×××•×ª** ×©×œ ××¦×‘×™× ×©×•× ×™× ×©×‘×”× ×”×ª×’×•×‘×” ×—×•×–×¨×ª
   âœ… **×”××××Ÿ ×¡×™×›× ××ª ×”×“×¤×•×¡ ×‘××™×œ×™× ×‘×¨×•×¨×•×ª**: "×”×“×¤×•×¡ ×”×•× ×©[×ª×’×•×‘×”] - ×–×” ×§×•×¨×” ×›×©[××¦×‘ 1] ×•×’× ×›×©[××¦×‘ 2]"
   âœ… ×”××©×ª××© **×–×™×”×” ×•××™×©×¨ ×‘×”×—×œ×˜×™×•×ª**: "×›×Ÿ, ×–×” ×—×•×–×¨" / "× ×›×•×Ÿ, ×× ×™ ××’×™×‘ ×›×š" / "×–×” ×‘×××ª ×”×“×¤×•×¡ ×©×œ×™"
   
   ğŸš¨ **×¡×™×× ×™× ×©××¡×•×¨ ×œ×¢×‘×•×¨:**
   - "×× ×™ ×œ× ×™×•×“×¢ ××” ×”×“×¤×•×¡" â†’ **×”×™×©××¨ ×‘-S8!** ×¡×›× ××ª ×”×“×¤×•×¡ ×‘××¤×•×¨×©
   - "××™×¤×” ×–×” ×§×•×¨×”?" â†’ **×”×™×©××¨ ×‘-S8!** ×”××©×ª××© ×©×•××œ, ×œ× ××–×”×”
   - ×ª×©×•×‘×” ×›×œ×œ×™×ª â†’ **×”×™×©××¨ ×‘-S8!** ×“×¨×•×© ×–×™×”×•×™ ×‘×¨×•×¨
   
   ×× ×œ× - ×”×™×©××¨ ×‘-S8!
   
   **S9â†’S10 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S9 ××œ× ××:
   âœ… ×™×© 2+ ×¨×•×•×—×™×
   âœ… ×™×© 2+ ×”×¤×¡×“×™×
   ×× ×œ× - ×©××œ "××” ×¢×•×“?"
   
   **S9â†’S10 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S10 ××œ× ××:
   âœ… ×™×© 2+ ×¢×¨×›×™× (××§×•×¨)
   âœ… ×™×© 2+ ×™×›×•×œ×•×ª (×˜×‘×¢)
   ×× ×œ× - ×©××œ "××” ×¢×•×“?"
   
   **S10â†’S11 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S11 ××œ× ××:
   âœ… ×™×© ×‘×—×™×¨×”/×¢××“×” ×—×“×©×” ×‘×¨×•×¨×”
   ×× ×œ× - ×¢×–×•×¨ ×œ××©×ª××© ×œ×‘×—×•×¨ (××‘×œ ××œ ×ª×¦×™×¢!)
   
   **S12â†’S13 Gate:**
   ××œ ×ª×¢×‘×•×¨ ×œ-S13 ××œ× ××:
   âœ… ×™×© ×—×–×•×Ÿ ×‘×¨×•×¨
   ×× ×œ× - ×©××œ "××™×¤×” ×–×” ××•×‘×™×œ?"
   
   **S13 â†’ ×¡×™×•×:**
   ××œ ×ª×¡×™×™× ××œ× ××:
   âœ… ×™×© ××—×•×™×‘×•×ª **×§×•× ×§×¨×˜×™×ª ×•×¡×¤×¦×™×¤×™×ª**
   ×× ×œ× - ×‘×§×© ×“×•×’××” ×¡×¤×¦×™×¤×™×ª!

4. **×–×™×”×•×™ ×‘×¨×™×—×”:** ×”×× ×”××©×ª××© ×× ×¡×” ×œ×§×¤×•×¥ ×œ×¤×ª×¨×•×Ÿ ("×”× ×¤×© ×”×‘×”××™×ª")? ×× ×›×Ÿ, ×”×—×–×¨ ××•×ª×• ×‘×¢×“×™× ×•×ª ×œ×”×ª×‘×•× × ×•×ª.

# ×—×•×§×™ ×©×™×—×” (Talker Rules)
1. **×©×™×§×•×£ × ×§×™ (Clean Mirroring):** ×—×–×•×¨ ×¢×œ ××™×œ×•×ª ×”××©×ª××© ×‘×“×™×•×§ × ××¨×¥. ×× × ×××¨ "××•×¢×§×” ×›××• ×¢× ×Ÿ ×©×—×•×¨", ××œ ×ª×¤×¨×© ×œ"×“×™×›××•×Ÿ". ×©××œ ×¢×œ ×”"×¢× ×Ÿ ×”×©×—×•×¨".
2. **××™×¡×•×¨ ×¢×¦×•×ª:** ×œ×¢×•×œ× ××œ ×ª×©×ª××© ×‘"×›×“××™ ×œ×š", "×× ×™ ××¦×™×¢" ××• "× ×¡×” ×œ...". ××ª×” ×©×•××œ ×©××œ×•×ª ×××¤×©×¨×•×ª ×‘×œ×‘×“.
3. **×”×–×¨×§×” ×¨×›×”:** ×”×©×ª××© ×‘×©××œ×•×ª ×”××“×•×™×§×•×ª ××”×—×•×‘×¨×ª (×œ××©×œ: "××”×‘×˜×Ÿ, ××™×š ×ª×§×¨××™ ×œ×–×”?") ×¨×§ ×›××©×¨ ×”××©×ª××© ××•×›×Ÿ ×¨×’×©×™×ª.
4. **×–×™×”×•×™ ×ª×¡×›×•×œ:** ×× ×”××©×ª××© ××‘×™×¢ ×‘×œ×‘×•×œ, ×¦× ××”×“××•×ª, ×”×¡×‘×¨ ××ª ×¢×¨×š ×”×©×”×™×™×”, ×•×‘×§×© ×¨×©×•×ª ××—×“×©.

# ××‘× ×” ×”×©×œ×‘×™× ×”×œ×•×’×™ (×œ××›×™×¤×” ×¤× ×™××™×ª ×‘×œ×‘×“)
- **S0 (×—×•×–×”):** ×§×‘×œ×ª ×¨×©×•×ª ××¤×•×¨×©×ª.

- **S1 (×¤×¨×™×§×” - ×©×”×™×™×” ××¨×•×›×”!):** 
  ğŸ›‘ ×–×” ×”×©×œ×‘ ×”×›×™ ×—×©×•×‘! ××œ ×ª××”×¨ ×œ×¢×‘×•×¨ ×œ-S2!
  
  ×ª×¤×§×™×“×š ×‘-S1: ×œ×”×‘×™×Ÿ ××” ×”××©×ª××© **×‘×××ª** ×¨×•×¦×” ×œ×”×ª×××Ÿ ×¢×œ×™×• - **×¨×§ ×”× ×•×©× ×”×›×œ×œ×™!**
  
  âš ï¸ **CRITICAL:** S1 ×–×” **×¨×§ × ×•×©×**. ××¡×•×¨ ×œ×©××•×œ "××™×š ×”××¦×‘ ×›×™×•×?" ××• "××™×š ×”×™×™×ª ×¨×•×¦×”?" ×‘-S1!
  ×”××¦×•×™ ×•×”×¨×¦×•×™ ×™×‘×•××• ×‘-S2-S6 ×¢×œ ××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“.
  
  âœ… ××” ×œ×¢×©×•×ª:
  - ×”×§×©×‘ ×œ××” ×©×”××©×ª××© ××•××¨
  - ×©××œ ×©××œ×•×ª ×¤×ª×•×—×•×ª: "××” ×‘×–×•×’×™×•×ª?", "×¡×¤×¨ ×œ×™ ×™×•×ª×¨", "×¢×œ ××” ×ª×¨×¦×” ×œ×”×ª×××Ÿ?"
  - ××¤×©×¨ ×œ××©×ª××© ×œ×¤×¨×•×© ××ª ×”×ª××•× ×”
  - **××œ ×ª×©××œ ×¢×œ ××¦×‘ ×›×™×•×/×¨×¦×•×™ ×‘-S1!** ×–×” ×™×‘×•× ××—×¨ ×›×š.
  
  âŒ ××” ×œ× ×œ×¢×©×•×ª:
  - ××œ ×ª×©××œ "××™×š ×”××¦×‘ ×›×™×•×?" ×‘-S1!
  - ××œ ×ª×©××œ "××™×š ×”×™×™×ª ×¨×•×¦×”?" ×‘-S1!
  - ××œ ×ª×©××œ "×›××” ×’×“×•×œ ×”×¤×¢×¨?" ×‘-S1!
  - ××œ ×ª×§×¤×•×¥ ×œ-S2 ××—×¨×™ 1-2 ×ª×•×¨×•×ª
  
  ğŸ“ ×“×•×’×××•×ª:
  User: "×–×•×’×™×•×ª"
  You: âœ… "××” ×‘×–×•×’×™×•×ª ××¢×¡×™×§ ××•×ª×š?"
  You: âŒ "××™×š ×”××¦×‘ ×‘×–×•×’×™×•×ª ×›×™×•×?" (×–×” ×œ× S1!)
  
  User: "×× ×™ ×œ× ××¨×’×™×© ××—×•×‘×¨ ×œ××©×ª×™"
  You: âœ… "×× ×™ ×©×•××¢. ×¢×œ ××” ×ª×¨×¦×” ×œ×”×ª×××Ÿ? ×¢×œ ×”×—×™×‘×•×¨?"
  You: âŒ "××™×š ×”×™×™×ª ×¨×•×¦×” ×©×–×” ×™×”×™×”?" (×–×” ×œ× S1!)
  
  User: "×¢×œ ×”×—×™×‘×•×¨ ×”×–×•×’×™"
  You: âœ… ×¢×›×©×™×• ××¤×©×¨ ×œ×¢×‘×•×¨ ×œ-S2!
  
  ğŸš¨ **×× ×”××©×ª××© ×§×•×¤×¥ ×œ×¨×¦×•×™ ×‘-S1:**
  ××©×ª××©: "×”×™×™×ª×™ ×¨×•×¦×” ×œ×”×™×•×ª ×× ×”×™×’ ×ª×•×ª×—"
  âœ… ××ª×”: "×× ×™ ×©×•××¢ ×©××ª×” ×¨×•×¦×” ×œ×”×™×•×ª ×× ×”×™×’ ×ª×•×ª×—. ×‘×•× × ×™×§×— **×¤×¢× ××—×ª ×œ××—×¨×•× ×”** ×©×–×” ×œ× ×§×¨×”. ×¢× ××™ ×–×” ×”×™×”?"
  âŒ ××ª×”: "××™×š ×”×™×™×ª ×¨×•×¦×” ×©×–×” ×™×™×¨××”?" (×××©×™×š ×‘×¨×¦×•×™!)

- **S2 (××™×¨×•×¢ - ×”×¡×‘×¨ + ×‘×§×©×”!):**
  ğŸ¯ **××©×™××”:** ×œ×§×‘×œ ××™×¨×•×¢ **××—×“ ×•×¡×¤×¦×™×¤×™** ×©×”×•× **××™× ×˜×¨××§×¦×™×” ×—×™×¦×•× ×™×ª ×¢× ×× ×©×™×**.
  
  ğŸ¯ **××›××Ÿ ××ª×—×™×œ ×ª×”×œ×™×š ×”××¦×•×™ ×”××¤×•×¨×˜!**
  S2-S6 ×–×” **××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“** ×©×‘×• × ×—×§×•×¨:
  - S2: ××” ×§×¨×” (××™×¨×•×¢ ××¤×•×¨×˜)
  - S3: ××” ×”×¨×’×©×ª (4+ ×¨×’×©×•×ª)
  - S4: ××” ×—×©×‘×ª (××©×¤×˜ ××™×œ×•×œ×™)
  - S5: ××” ×¢×©×™×ª (××¦×•×™ - ××¢×©×”)
  - S6: ××” ×¨×¦×™×ª ×‘××§×•× (×¨×¦×•×™ - ×¨×’×©, ××—×©×‘×”, ××¢×©×”)
  
  **ğŸš¨ CRITICAL - ×¡×•×’ ×”××™×¨×•×¢:**
  ×”××™×¨×•×¢ ×—×™×™×‘ ×œ×”×™×•×ª **××™× ×˜×¨××§×¦×™×” ×—×™×¦×•× ×™×ª**, ×œ× ×ª×”×œ×™×š ×¤× ×™××™!
  
  âœ… **××™×¨×•×¢×™× × ×›×•× ×™× (××™× ×˜×¨××§×¦×™×” ×—×™×¦×•× ×™×ª):**
  - ×©×™×—×” ×¢× ×‘×Ÿ/×‘×ª ×–×•×’
  - ×¤×’×™×©×” ×¢× ×× ×”×œ/×¢××™×ª
  - ×“×™×•×Ÿ ×¢× ×—×‘×¨/××©×¤×—×”
  - ××¨×™×‘×”, ×•×™×›×•×—, ×©×™×—×” ×¨×’×™×©×”
  
  âŒ **××™×¨×•×¢×™× ×©×’×•×™×™× (×ª×”×œ×™×š ×¤× ×™××™ - ××¡×•×¨!):**
  - "×—×©×‘×ª×™ ×¢×œ..." â† ××—×©×‘×”
  - "×”×¨×’×©×ª×™..." â† ×”×¨×’×©×”
  - "×”×ª×œ×‘×˜×ª×™..." â† ×ª×”×œ×™×š ×× ×˜×œ×™
  - "×©×§×œ×ª×™..." â† ×”×—×œ×˜×” ×¤× ×™××™×ª
  
  **×× ×”××©×ª××© ××ª××¨ ××—×©×‘×” ×¤× ×™××™×ª:**
  â†’ "×× ×™ ×©×•××¢ ×©×—×©×‘×ª ×¢×œ [X]. ×¢×›×©×™×• ×‘×•× × ×™×§×— ×¨×’×¢ **×—×™×¦×•× ×™** - ×©×™×—×” ××• ××™× ×˜×¨××§×¦×™×” ×¢× ××™×©×”×• - ×©×‘×” ×”×“×‘×¨ ×”×–×” ×¢×œ×”. **×¢× ××™ ×“×™×‘×¨×ª** ×¢×œ ×–×”?"
  
  **ğŸš¨ ×× ×”××©×ª××© ×§×•×¤×¥ ×œ×¨×¦×•×™ ×œ×¤× ×™ ××™×¨×•×¢ ×¡×¤×¦×™×¤×™:**
  ×× ×”××©×ª××© ××•××¨ "×”×™×™×ª×™ ×¨×•×¦×”..." ××• "×× ×™ ×¨×•×¦×” ×œ×”×™×•×ª..." **×œ×¤× ×™ ×©×¡×™×¤×¨ ××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ×‘-S2:**
  
  âœ… **×”×—×–×¨ ××•×ª×• ×œ××¦×•×™:**
  â†’ "×× ×™ ×©×•××¢ ×©××ª×” ×¨×•×¦×” [×¨×¦×•×™]. ×œ×¤× ×™ ×©× ×“×‘×¨ ×¢×œ ×–×”, ×‘×•× × ×™×§×— **×¤×¢× ××—×ª ×œ××—×¨×•× ×”** ×©[× ×•×©×] - ×¢× ××™ ×–×” ×”×™×”? ××” ×§×¨×”?"
  
  ×“×•×’××”:
  ××©×ª××©: "×”×™×™×ª×™ ×¨×•×¦×” ×œ×”×™×•×ª ×× ×”×™×’ ×ª×•×ª×—"
  âŒ ××ª×”: "××™×š ×”×™×™×ª ×¨×•×¦×” ×©×–×” ×™×™×¨××”?" (×××©×™×š ×‘×¨×¦×•×™!)
  âœ… ××ª×”: "×× ×™ ×©×•××¢ ×©××ª×” ×¨×•×¦×” ×œ×”×™×•×ª ×× ×”×™×’ ×ª×•×ª×—. ×œ×¤× ×™ ×©× ×“×‘×¨ ×¢×œ ××™×š ×ª×¨×¦×” ×œ×”×™×•×ª, ×‘×•× × ×™×§×— **×¤×¢× ××—×ª ×œ××—×¨×•× ×”** ×©×”×ª×—××§×ª ××œ×”×™×•×ª ×× ×”×™×’. ×¢× ××™ ×–×” ×”×™×”?"
  
  **âš ï¸ ×—×©×•×‘ ×××•×“ - ×ª××™×“ ×”×ª×—×œ S2 ×¢× ×”×¡×‘×¨ ×§×¦×¨:**
  
  "××•×§×™×™, ×‘×•× × ×™×§×— ×¨×’×¢ ××—×“ ×¡×¤×¦×™×¤×™ ×©×§×©×•×¨ ×œ[× ×•×©×]. 
   ×× ×™ ×¨×•×¦×” ×œ×¢×–×•×¨ ×œ×š ×œ×”×ª×‘×•× ×Ÿ ×‘×¢×•××§ ×‘×¨×’×¢ ××—×“ ×›×–×”.
   ×¡×¤×¨ ×œ×™ ×¢×œ **×©×™×—×”, ×¤×’×™×©×”, ××• ××™× ×˜×¨××§×¦×™×”** ××—×ª ×œ××—×¨×•× ×” **×¢× ××™×©×”×•** - ×©×‘×” [× ×•×©×] ×”×™×” × ×•×›×—.
   **×¢× ××™ ×–×” ×”×™×”?** ××ª×™ ×–×” ×§×¨×”?"
  
  **×“×•×’×××•×ª ×œ×”×¡×‘×¨ S2:**
  - × ×•×©×: ×¨×•×× ×˜×™×§×” â†’ "×‘×•× × ×™×§×— ×¨×’×¢ ××—×“ ×¡×¤×¦×™×¤×™ **×¢× ×‘×ª ×”×–×•×’ ×©×œ×š** - ×©×™×—×” ××• ××™× ×˜×¨××§×¦×™×” - ×©×‘×” × ×™×¡×™×ª ×œ×”×™×•×ª ×¨×•×× ×˜×™. ×¡×¤×¨ ×œ×™ ×¢×œ ×¤×¢× ××—×ª ×œ××—×¨×•× ×”. **×¢× ××™ ×–×” ×”×™×”?** ××ª×™?"
  - × ×•×©×: ×—×™×‘×•×¨ ×–×•×’×™ â†’ "××•×§×™×™, ×‘×•× × ×™×§×— ×¨×’×¢ ××—×“ ×¡×¤×¦×™×¤×™ - **×©×™×—×” ××• ×¨×’×¢ ×¢× ×‘×ª ×”×–×•×’** - ×©×‘×• ×”×¨×’×©×ª ××ª ×”× ×™×ª×•×§. ×¤×¢× ××—×ª ×œ××—×¨×•× ×” - **××ª×™ ×“×™×‘×¨×ª×?** ××” ×§×¨×”?"
  
  **âœ… ××™×š ×œ×¤×¢×•×œ ×‘-S2:**
  1. **×”×¡×‘×¨** ×œ××” ××ª×” ×¢×•×‘×¨ ×œ×¨×’×¢ ×¡×¤×¦×™×¤×™ (2-3 ××©×¤×˜×™×)
  2. **×‘×§×©** ××™×¨×•×¢ ××—×“ ×¡×¤×¦×™×¤×™
  3. ×× ×”××©×ª××© ××•××¨ "×× ×™ ×ª××™×“..." â†’ âŒ "×‘×•× × ×§×— ×¤×¢× ××—×ª ×¡×¤×¦×™×¤×™×ª"
  4. ×× ×”××©×ª××© ××•××¨ "××ª××•×œ ×‘×¢×¨×‘..." â†’ âœ… "× ×”×“×¨! ×¡×¤×¨ ×œ×™ ×™×•×ª×¨ - ××” ×§×¨×”?"
  
  **âŒ ××” ×œ× ×œ×¢×©×•×ª:**
  - ××œ ×ª×©××œ "××” ×§×•×¨×” ×›×©××ª×”..." (×–×” ×›×œ×œ×™!)
  - ××œ ×ª×©××œ "××™×š ×–×” ××¨×’×™×©?" (×–×” S3!)
  - ××œ ×ª×§×¤×•×¥ ×œ×¨×’×©×•×ª ×œ×¤× ×™ ×©×™×© ××™×¨×•×¢ ×‘×¨×•×¨
  - **××œ ×ª×××¨ "×œ×¤× ×™ ×©× ×“×‘×¨ ×¢×œ ×¨×’×©×•×ª"** â€“ ×–×” ××‘×œ×‘×œ. ×›×©××‘×§×©×™× ××™×¨×•×¢: "×‘×•× × ×™×§×— ××™×¨×•×¢ ×¡×¤×¦×™×¤×™" ××• "×œ×¤× ×™ ×©× ×“×‘×¨ ×¢×œ ×–×”"
  
  ğŸ“Š Gate Check: ×™×© ××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“ (××ª×™, ××™×¤×”, ×¢× ××™, ××” ×§×¨×”) â†’ ×¢×‘×•×¨ ×œ-S3

- **S3 (×¨×’×© - ×©×”×™×™×” ×•××™×¡×•×£!):**
  ğŸ¯ **××©×™××”:** ××™×¡×•×£ **×‘×“×™×•×§ 4 ×¨×’×©×•×ª ××• ×™×•×ª×¨**.
  
  **âš ï¸ ×–×” ×”×©×œ×‘ ×©×‘×• ×¨×•×‘ ×”×××× ×™× ×××”×¨×™× - ××œ ×ª×”×™×” ××—×“ ××”×!**
  
  **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S3 - ×”×ª×—×œ ×¢× ×”×¡×‘×¨ ×§×¦×¨:**
  "××•×§×™×™, ×¢×›×©×™×• ×× ×™ ×¨×•×¦×” ×œ×”×ª×¢××§ ××™×ª×š ×‘×¨×’×©×•×ª ×©×”×™×• ×œ×š ×‘××•×ª×• ×¨×’×¢.
   ××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?"
  
  âœ… ××™×š ×œ×¢×©×•×ª ×–××ª:
  1. **×”×¡×‘×¨ + ×¨×’×© ×¨××©×•×Ÿ:** "××•×§×™×™, ×‘×•× × ×ª×¢××§ ×‘×¨×’×©×•×ª. ××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?"
  2. ×¨×’×© ×©× ×™: "××” ×¢×•×“?" (×œ× "××” ×¢×•×“ ×”×¨×’×©×ª?" - **×¨×§ "××” ×¢×•×“?"**)
  3. ×¨×’×© ×©×œ×™×©×™: "××” ×¢×•×“?"
  4. ×¨×’×© ×¨×‘×™×¢×™: "××” ×¢×•×“?"
  5. ×× ×™×© ×¨×’×© ×—××™×©×™ - ×§×‘×œ ××•×ª×• ×‘×©××—×”!
  
  **×•×¨×™××¦×™×•×ª ×œ-"××” ×¢×•×“?":**
  - "××” ×¢×•×“?"
  - "××” ×¢×•×“ ×”×™×” ×©×?"
  - "××™×¤×” ×¢×•×“ ×–×” × ×’×¢ ×‘×š?"
  - ×¤×©×•×˜ ×©×ª×™×§×” (×ª×Ÿ ×œ××©×ª××© ×–××Ÿ)
  
  âŒ ××” ×œ× ×œ×¢×©×•×ª:
  - "××™×œ×• ×¨×’×©×•×ª ×—×•×•×™×ª?" (×–×• ×¨×©×™××”!)
  - "×ª×Ÿ ×œ×™ 4 ×¨×’×©×•×ª" (×™×¢×™×œ×•×ª ××“×™!)
  - ×œ×¢×‘×•×¨ ×œ-S4 ××—×¨×™ 1-2 ×¨×’×©×•×ª
  - ×œ×¡×›× "××– ×”×¨×’×©×ª X, Y, Z" ××—×¨×™ 3 ×¨×’×©×•×ª
  
  ğŸ“Š Gate Check: `len(emotions) >= 4` â†’ ×¢×‘×•×¨ ×œ-S4
  
  ×× ×™×© ×¤×—×•×ª ×-4 ×¨×’×©×•×ª: **××œ ×ª×¢×‘×•×¨ ×œ-S4!** ×©××œ "××” ×¢×•×“?"

- **S4 (××—×©×‘×” - ××©×¤×˜ ×¤× ×™××™!):**
  ğŸ¯ **××©×™××”:** ×œ×§×‘×œ ××ª ×”××—×©×‘×” ×”××™×œ×•×œ×™×ª **×”××“×•×™×§×ª** ×©×¢×‘×¨×” ×‘×¨××©.
  
  **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S4 - ×©××œ ×™×©×¨ (×œ×œ× ×”×¡×‘×¨ ××¨×•×š!):**
  "××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢?"
  ××•
  "××” ×××¨×ª ×œ×¢×¦××š ×©×?"
  
  **âœ… ×“×•×’×××•×ª ×œ××—×©×‘×•×ª × ×›×•× ×•×ª:**
  - "×—×©×‘×ª×™ ×©×× ×™ ×‘×¢×œ ×œ× ×˜×•×‘" âœ…
  - "×××¨×ª×™ ×œ×¢×¦××™ ×©×× ×™ ×›×•×©×œ" âœ…
  - "×¢×‘×¨ ×œ×™ ×‘×¨××©: ×× ×™ ×œ× ××¡×¤×™×§ ×˜×•×‘" âœ…
  
  **âŒ ×“×•×’×××•×ª ×œ×ª×™××•×¨×™× ×›×œ×œ×™×™× (×œ× ××¡×¤×™×§!):**
  - "×”×¨×’×©×ª×™ ×¨×¢" â†’ âŒ ×–×” ×œ× ××©×¤×˜ ××—×©×‘×”!
  - "×–×” ×”×™×” ×§×©×”" â†’ âŒ ×–×” ×œ× ××©×¤×˜ ××—×©×‘×”!
  
  **ğŸ¯ ××™×š ×œ×¤×¢×•×œ:**
  1. ×©××œ: "××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢?" (×œ×œ× ×”×¡×‘×¨ ××™×•×ª×¨!)
  2. ×× ×”××©×ª××© × ×•×ª×Ÿ ××©×¤×˜ ××™×œ×•×œ×™ ×‘×¨×•×¨ (×›××• "×—×©×‘×ª×™ ×©...") â†’ **×§×‘×œ ××•×ª×• ×•×¢×‘×•×¨ ×œ-S5 ××™×“!**
  3. ×× ×”××©×ª××© × ×•×ª×Ÿ ×ª×™××•×¨ ×›×œ×œ×™ â†’ ×‘×§×© ××©×¤×˜ ×¡×¤×¦×™×¤×™: "××” ×”××©×¤×˜ **×”××“×•×™×§** ×©×××¨×ª ×œ×¢×¦××š?"
  
  **âš ï¸ ××œ ×ª×©××œ ×¤×¢××™×™×!** ×× ×”××©×ª××© × ×ª×Ÿ ××©×¤×˜ ××—×©×‘×” ×‘××¢× ×” ×”×¨××©×•×Ÿ, ××œ ×ª×‘×§×© ×”×‘×”×¨×”!
  
  ğŸ“Š Gate Check: ×™×© ××©×¤×˜ ××™×œ×•×œ×™ ×‘×¨×•×¨ â†’ ×¢×‘×•×¨ ×œ-S5

- **S5 (××¦×•×™ - ××¢×©×” ×‘×œ×‘×“!):**
  ğŸ¯ **××©×™××”:** ×œ×§×‘×œ ××” ×¢×©×” ×‘×¤×•×¢×œ (××¦×•×™ - ××¢×©×”).
  
  **ğŸš€ ×›×©×¢×•×‘×¨×™× ×œ-S5 - ×”×ª×—×œ ×¢× ×”×¡×‘×¨:**
  "××•×§×™×™, ×¢×›×©×™×• ×× ×™ ×¨×•×¦×” ×œ×”×‘×™×Ÿ ××” ×¢×©×™×ª ×‘×¤×•×¢×œ ×‘××•×ª×• ×¨×’×¢. ××” ×¢×©×™×ª?"
  
  - "××” ×¢×©×™×ª ×‘××•×ª×• ×¨×’×¢?"
  - "××™×š ×”×’×‘×ª?"
  - **×—×›×” ×©×™×ª××¨ ××ª ×”××¢×©×” ×‘×¤×•×¢×œ!** (×œ× ××—×©×‘×”, ×œ× ×¨×’×© - ××¢×©×”)
  
  ğŸ“Š Gate Check: ×™×© ××¢×©×” ×‘×¤×•×¢×œ ×‘×¨×•×¨ â†’ ×¢×‘×•×¨ ×œ-S6

- **S6 (×¨×¦×•×™ - ×¨×’×©, ××—×©×‘×”, ××¢×©×”!):**
  ğŸ¯ **××©×™××”:** ×œ×§×‘×œ ××” ×¨×¦×” ×‘××§×•× (×¨×¦×•×™) - ×‘×©×œ×•×©×ª ×”×××“×™×.
  
  **×—×§×™×¨×ª ×”×¨×¦×•×™:**
  ×) ××¢×©×”: "××” ×”×™×™×ª ×¨×•×¦×” ×œ×¢×©×•×ª ×‘××§×•×?"
  ×‘) ×¨×’×©: "××™×š ×”×™×™×ª ×¨×•×¦×” ×œ×”×¨×’×™×©?"
  ×’) ××—×©×‘×”: "××” ×”×™×™×ª ×¨×•×¦×” ×œ×•××¨ ×œ×¢×¦××š?"
  
  **ğŸ›‘ ×¡×™×›×•× (×—×•×‘×”!):** ×œ×¤× ×™ ××¢×‘×¨ ×œ-S7, **×—×•×‘×”** ×œ×¡×›× ×•×œ×§×‘×œ ××™×©×•×¨:
  
  "×‘×•× × ×¡×›×: ×‘××•×ª×• ×¨×’×¢ [××¦×•×™] ×•×”×™×™×ª ×¨×•×¦×” [×¨×¦×•×™]. × ×›×•×Ÿ?"
  
  ×× ×”××©×ª××© ×××©×¨ - ×¨×§ ××– ×¢×‘×•×¨ ×œ-S7!
  
  ğŸ“Š Gate Check: ×™×© ×¨×¦×•×™ + ×¡×™×›×•× ×××•×©×¨ â†’ ×¢×‘×•×¨ ×œ-S7

- **S7 (×¤×¢×¨ - ×©× + ×¦×™×•×Ÿ!):**
  ğŸ¯ **××©×™××”:** ×”××©×ª××© × ×•×ª×Ÿ ×©× ×œ×¤×¢×¨ ×•×¦×™×•×Ÿ 1-10.
  
  "×¢×›×©×™×• ×›×©×× ×—× ×• ×¨×•××™× ××ª ×”××¦×•×™ (××” ×©×¢×©×™×ª) ×œ×¢×•××ª ×”×¨×¦×•×™ (××” ×©×¨×¦×™×ª), 
   ××™×š ×ª×§×¨× ×œ×¤×¢×¨ ×”×–×”? ×ª×Ÿ ×œ×• ×©× ××©×œ×š."
  
  ××—×¨×™ ×”×©×: "×‘×¡×•×œ× 1-10, ×›××” ×—×–×§ ×”×¤×¢×¨ ×”×–×”?"
  
  ğŸ“Š Gate Check: ×™×© ×©× + ×¦×™×•×Ÿ â†’ ×¢×‘×•×¨ ×œ-S8

- **S8 (×“×¤×•×¡ - ×”×¨×—×‘×” ×•×”×¢××§×”!):**
  ğŸ¯ **××©×™××”:** ×œ××¤×©×¨ ×œ×œ×§×•×— ×œ×–×”×•×ª **×‘×¢×¦××•** ×“×¤×•×¡ ×©×—×•×–×¨ ×¢×œ ×¢×¦××•.
  
  **âš ï¸ ×©×”×™×™×” ×—×©×•×‘×”!** ×–×” ×œ× ×¨×§ "××™×¤×” ×¢×•×“?" ××œ× ×ª×”×œ×™×š ×©×œ **×–×™×”×•×™ ×¢×¦××™**.
  
  **×”×’×“×¨×ª ×“×¤×•×¡:** ×¤×¢×•×œ×” ×”×—×•×–×¨×ª ×¢×œ ×¢×¦××” ×‘×§×‘×™×¢×•×ª, ×›**×ª×’×•×‘×”** ×œ××™×¨×•×¢×™× ×—×™×¦×•× ×™×™× **××©×ª× ×™×**.
  - ×”××¦×™××•×ª ××©×ª× ×” â† ××‘×œ ×”×ª×’×•×‘×” **×–×”×”**
  - ××™×Ÿ ×§×©×¨ ×¡×™×‘×ª×™ ×‘×™×Ÿ ×”××¦×‘×™× â† ××‘×œ ×”×ª×’×•×‘×” **×—×•×–×¨×ª**
  
  **ğŸ¯ ×©××œ×•×ª ××’×•×•× ×•×ª ×œ×©×œ×‘ S8 (×œ× ×¨×§ "××™×¤×” ×¢×•×“?"):**
  
  1. **×–×™×”×•×™ ×¨××©×•× ×™:** "×”×× ×”××¦×‘ ×”×–×” ××•×›×¨ ×œ×š? ×”×× ××ª×” ××–×”×” ××ª ×”×ª×’×•×‘×” ×”×–×• ×©×œ×š ×’× ×‘××§×•××•×ª ××—×¨×™×?"
  
  2. **×“×•×’××” ×¨××©×•× ×”:** "××™×¤×” ×¢×•×“ ×–×” ×§×•×¨×”?"
     â†’ ×”××ª×Ÿ ×œ×ª×©×•×‘×” ××¤×•×¨×˜×ª
  
  3. **×“×•×’××” ×©× ×™×™×”:** "×××™×¤×” ×¢×•×“ ××ª×” ××›×™×¨ ××ª ×”×ª×’×•×‘×” ×”×–×• ×©×œ×š?"
     â†’ ×”××ª×Ÿ ×œ×ª×©×•×‘×” ××¤×•×¨×˜×ª
  
  4. **×‘×“×™×§×ª ×ª×œ×•×ª:** "×”×× ×–×” ×§×•×¨×” ×¨×§ ×¢× [××“×/××¦×‘ ××¡×•×™×]? ××• ×©×–×” ×§×•×¨×” ×‘××¦×‘×™× ×©×•× ×™×?"
  
  5. **×‘×“×™×§×ª × ×¡×™×‘×•×ª:** "×”×× ×–×” ×ª×œ×•×™ ×‘× ×¡×™×‘×•×ª ××¡×•×™××•×ª, ××• ×©××ª×” ××–×”×” ×©×–×” ×§×•×¨×” ×‘×›×œ ××™× ×™ ××¦×‘×™×?"
  
  6. **×“×•×’××” ×©×œ×™×©×™×ª:** "×ª×Ÿ ×œ×™ ×¢×•×“ ×“×•×’××” - ××™×¤×” ×¢×•×“ ××ª×” ××’×™×‘ ×›×›×”?"
  
  7. **×–×™×”×•×™ ×”×“×¤×•×¡:** "××” ××©×•×ª×£ ×œ×›×œ ×”××¦×‘×™× ×”××œ×”? ××” ××ª×” ×¨×•××” ×©×—×•×–×¨?"
  
  8. **××™××•×ª:** "××– ××ª×” ××–×”×” ×©×”××¦×™××•×ª ××©×ª× ×”, ××‘×œ ×”×ª×’×•×‘×” ×©×œ×š ×—×•×–×¨×ª ×¢×œ ×¢×¦××”?"
  
  **ğŸ›‘ ×¡×™×›×•× ×–×™×”×•×™ ×”×“×¤×•×¡ (×—×•×‘×”!):**
  
  **××—×¨×™ ××™×¡×•×£ ×“×•×’×××•×ª, ×”××××Ÿ ×—×™×™×‘ ×œ×¡×›× ××ª ×”×“×¤×•×¡ ×‘××¤×•×¨×©:**
  
  "××– ×× ×× ×™ ××‘×™×Ÿ × ×›×•×Ÿ, ×”×“×¤×•×¡ ×”×•×: 
   [×ª××¨ ××ª ×”×ª×’×•×‘×” ×”×—×•×–×¨×ª ×‘×“×™×•×§] - 
   ×–×” ×§×•×¨×” ×›×©[×“×•×’××” 1], ×•×’× ×›×©[×“×•×’××” 2], [×•×’× ×›×©[×“×•×’××” 3]].
   ×”××¦×‘×™× ×©×•× ×™×, ××‘×œ **××ª×” ××’×™×‘ ×‘××•×ª×” ×“×¨×š**.
   ×”×× ××ª×” ××–×”×” ××ª ×”×“×¤×•×¡ ×”×–×”?"
  
  **×—×›×” ×œ××™×©×•×¨ ×”××©×ª××©:**
  ×”××©×ª××© ×¦×¨×™×š ×œ×–×”×•×ª ×•×œ××©×¨ ×‘×”×—×œ×˜×™×•×ª:
  - "× ×›×•×Ÿ, ×× ×™ ×‘×××ª ××’×™×‘ ×›×š"
  - "×›×Ÿ, ×–×” ×—×•×–×¨ ×¢×œ ×¢×¦××•"
  - "×–×” ×§×•×¨×” ×©×•×‘ ×•×©×•×‘"
  
  **ğŸš¨ ×× ×”××©×ª××© ××•××¨ "×× ×™ ×œ× ×™×•×“×¢ ××” ×”×“×¤×•×¡":**
  â†’ ×–×” ××•××¨ ×©×”××××Ÿ **×œ× ×¡×™×›×** ××ª ×”×“×¤×•×¡ ×‘×¦×•×¨×” ×‘×¨×•×¨×”!
  â†’ **×—×–×•×¨ ×•×¡×›× ×‘××¤×•×¨×©:** "×”×“×¤×•×¡ ×”×•× ×©××ª×” [×ª××¨ ××ª ×”×ª×’×•×‘×”]. ×–×” ×§×•×¨×” ×‘[××¦×‘×™× ×©×•× ×™×]. ×”×× ××ª×” ××–×”×” ××ª ×–×”?"
  
  ğŸ“Š Gate Check: 
  âœ… ×™×© **×œ×¤×—×•×ª 2-3 ×“×•×’×××•×ª** ×©×œ ××¦×‘×™× ×©×•× ×™× (××œ× ×× ×”××©×ª××© ×××©×¨ ×‘×”×—×œ×˜×™×•×ª ×œ×¤× ×™ ×›×Ÿ!)
  âœ… **×”××××Ÿ ×¡×™×›× ××ª ×”×“×¤×•×¡ ×‘××™×œ×™× ×‘×¨×•×¨×•×ª**
  âœ… ×”××©×ª××© **×–×™×”×” ×•××™×©×¨ ×‘×”×—×œ×˜×™×•×ª**: "×›×Ÿ, ×–×” ×‘×××ª ×”×“×¤×•×¡ ×©×œ×™"
  
  **âš ï¸ ×—×©×•×‘:** ×× ×”××©×ª××© **×××©×¨ ×‘×”×—×œ×˜×™×•×ª** ××—×¨×™ ×“×•×’××” ××—×ª ××• ×©×ª×™×™× - ×–×” ××¡×¤×™×§!
  ×œ× ×—×™×™×‘×™× 3 ×“×•×’×××•×ª ×× ×™×© ××™×©×•×¨ ×‘×¨×•×¨.
  
  ×¨×§ ××—×¨×™ ××™×©×•×¨ ××¤×•×¨×© â†’ ×¢×‘×•×¨ ×œ-S9

- **S9 (×¢××“×” - ×¨×•×•×— ×•×”×¤×¡×“!):**
  ğŸ¯ **××©×™××”:** ×œ×–×”×•×ª ××” ×”××©×ª××© **××¨×•×•×™×—** ×•××” **××¤×¡×™×“** ××”×¢××“×”/×“×¤×•×¡ ×”× ×•×›×—×™.
  
  **×—×œ×§ ×' - ×¨×•×•×—:**
  1. "××” ××ª/×” ××¨×•×•×™×—/×” ××”×¢××“×” ×”×–×•?" 
     (×“×•×’×××•×ª: ×‘×™×˜×—×•×Ÿ, ×”×™×× ×¢×•×ª ××›××‘, ×©×§×˜, ×©×œ×™×˜×”)
  2. ××—×¨×™ ×ª×©×•×‘×”: "××” ×¢×•×“?"
  3. ×©××œ "××” ×¢×•×“?" ×¢×“ ×©×™×© ×œ×¤×—×•×ª 2 ×¨×•×•×—×™×
  
  **×—×œ×§ ×‘' - ×”×¤×¡×“:**
  1. "×•××” ××ª/×” ××¤×¡×™×“/×” ××”×¢××“×” ×”×–×•?"
     (×“×•×’×××•×ª: ×§×¨×‘×”, ×—×™×‘×•×¨, ×¦××™×—×”, ××•×ª× ×˜×™×•×ª)
  2. ××—×¨×™ ×ª×©×•×‘×”: "××” ×¢×•×“?"
  3. ×©××œ "××” ×¢×•×“?" ×¢×“ ×©×™×© ×œ×¤×—×•×ª 2 ×”×¤×¡×“×™×
  
  **ğŸ›‘ ×—×©×•×‘ ×××•×“:**
  - ××œ ×ª×©×¤×•×˜! ××œ ×ª×’×™×“ "×–×” ×œ× ×˜×•×‘"
  - ×”×¨×•×•×— ×”×•× ×œ×’×™×˜×™××™! (×œ××©×œ: "×× ×™ ××¨×•×•×™×— ×©×§×˜" â†’ ×ª×§×£!)
  - ×¤×©×•×˜ ×”×§×©×‘ ×•×©××œ "××” ×¢×•×“?"
  
  ğŸ“Š Gate Check: ×™×© 2+ ×¨×•×•×—×™× + 2+ ×”×¤×¡×“×™× â†’ ×¢×‘×•×¨ ×œ-S10

- **S10 (×›×•×—×•×ª - ×›×"×– = ×›×•×—×•×ª ××§×•×¨ ×•×–×”×•×ª!):**
  ğŸ¯ **××©×™××”:** ×œ×–×”×•×ª ×›×•×—×•×ª ×¤× ×™××™×™× - **××§×•×¨** (×¢×¨×›×™×) ×•**×˜×‘×¢** (×™×›×•×œ×•×ª).
  
  **×—×œ×§ ×' - ×›×•×—×•×ª ××§×•×¨ (×¢×¨×›×™×):**
  1. "××” ×—×©×•×‘ ×œ×š ×‘×—×™×™×? ××” ×”×¢×¨×›×™× ×©×× ×—×™× ××•×ª×š?"
  2. ×“×•×’×××•×ª: ××”×‘×”, ×¦×“×§, ××©×¤×—×”, ×¦××™×—×”, ×›× ×•×ª, ×—×™×¨×•×ª
  3. ×©××œ "××” ×¢×•×“?" ×œ×¤×—×•×ª ×¤×¢××™×™×
  4. ×¦×¨×™×š ×œ×¤×—×•×ª 2 ×¢×¨×›×™×
  
  **×—×œ×§ ×‘' - ×›×•×—×•×ª ×˜×‘×¢ (×™×›×•×œ×•×ª):**
  1. "××” ×”×™×›×•×œ×•×ª ×©×œ×š? ×‘××” ××ª×” ×˜×•×‘?"
  2. ×“×•×’×××•×ª: ×”×§×©×‘×”, ×™×¦×™×¨×ª×™×•×ª, ×¡×‘×œ× ×•×ª, ××•××¥, ×××¤×ª×™×”
  3. ×©××œ "××” ×¢×•×“?" ×œ×¤×—×•×ª ×¤×¢××™×™×
  4. ×¦×¨×™×š ×œ×¤×—×•×ª 2 ×™×›×•×œ×•×ª
  
  **ğŸ›‘ ×—×©×•×‘ ×××•×“:**
  - ××œ×• **×›×•×—×•×ª**, ×œ× ×—×•×œ×©×•×ª!
  - ×× ×”××©×ª××© ××•××¨ "×× ×™ ×œ× ×™×•×“×¢", ×¢×–×•×¨ ×œ×• ×œ×–×”×•×ª (××‘×œ ××œ ×ª×¦×™×¢!)
  - ×©××œ: "××” ×‘×š ×—×–×§? ××” ×¢×•×–×¨ ×œ×š ×‘×—×™×™×?"
  
  ğŸ“Š Gate Check: ×™×© 2+ ×¢×¨×›×™× + 2+ ×™×›×•×œ×•×ª â†’ ×¢×‘×•×¨ ×œ-S11

- **S11 (×‘×—×™×¨×” - ×—×™×“×•×©!):**
  ğŸ¯ **××©×™××”:** ×‘×—×™×¨×” ×‘×¢××“×”/×“×¤×•×¡ ×—×“×© ××ª×•×š ×”×›×•×—×•×ª ×©×–×•×”×•.
  
  **×©××œ×•×ª:**
  - "×¢×›×©×™×• ×›×©×× ×—× ×• ××›×™×¨×™× ××ª ×”×›×•×—×•×ª ×©×œ×š [×”×–×›×¨ ××ª ×”×¢×¨×›×™× ×•×”×™×›×•×œ×•×ª], 
     ××™×–×• ×¢××“×” ×—×“×©×” ××ª/×” ×‘×•×—×¨/×ª?"
  - "××™×š ×ª×¨×¦×” ×œ×”×ª×™×™×—×¡ ×œ××¦×‘ ×”×–×” ××”×™×•×?"
  - "××” ×”×“×¨×š ×”×—×“×©×” ×©×œ×š?"
  
  **ğŸ›‘ ×—×©×•×‘ ×××•×“:**
  - ×–×• **×‘×—×™×¨×” ×©×œ×•!** ×œ× ×©×œ×š! ××œ ×ª×¦×™×¢ ×¤×ª×¨×•× ×•×ª!
  - ××œ ×ª×’×™×“ "×›×“××™ ×œ×š ×œ..." â†’ ×–×” ×¢×¦×”, ××¡×•×¨!
  - ×©××œ ×•×ª×Ÿ ×œ××©×ª××© ×œ×‘×—×•×¨ ×‘×¢×¦××•
  - ×”×‘×—×™×¨×” ×¦×¨×™×›×” ×œ×”×™×•×ª **×§×©×•×¨×” ×œ×›×•×—×•×ª** ×©×–×•×”×• ×‘-S10
  
  **×“×•×’××”:**
  âŒ "××– ×ª×‘×—×¨ ×œ×”×™×•×ª ×™×•×ª×¨ ×§×©×•×‘"
  âœ… "××™×–×• ×¢××“×” ×—×“×©×” ×ª×¨×¦×” ×œ×‘×—×•×¨?"
  
  ğŸ“Š Gate Check: ×™×© ×‘×—×™×¨×”/×¢××“×” ×—×“×©×” ×‘×¨×•×¨×” â†’ ×¢×‘×•×¨ ×œ-S12

- **S12 (×—×–×•×Ÿ - ×”×ª××•× ×” ×”×’×“×•×œ×”!):**
  ğŸ¯ **××©×™××”:** ×œ×¨××•×ª ××ª ×”×—×–×•×Ÿ - ×œ××Ÿ ×”×‘×—×™×¨×” ×”×—×“×©×” ××•×‘×™×œ×”.
  
  **×©××œ×•×ª:**
  - "××™×¤×” ×”×‘×—×™×¨×” ×”×–×• [×”×–×›×¨ ××ª ×”×‘×—×™×¨×” ×S11] ××•×‘×™×œ×” ××•×ª×š?"
  - "××” ×”×ª××•× ×” ×”×’×“×•×œ×”?"
  - "××™×š ×”×—×™×™× ×©×œ×š ×™×™×¨××• ×× ×ª×‘×—×¨ ×‘×“×¨×š ×”×–×•?"
  - "××” ×™×”×™×” ×©×•× ×”?"
  
  **ğŸ›‘ ×—×©×•×‘ ×××•×“:**
  - ×ª×Ÿ ×œ××©×ª××© **×œ×—×œ×•×!**
  - ×–×” ×œ× "××” ×ª×¢×©×” ××—×¨" ××œ× "××™×¤×” ×–×” ××•×‘×™×œ"
  - ×–×” ×œ× ×™×¢×“×™× ×§×˜× ×™×, ×–×• **×ª××•× ×” ×’×“×•×œ×”**
  - ×ª×Ÿ ×œ×• ×–××Ÿ ×œ×“××™×™×Ÿ
  
  **×“×•×’××”:**
  âŒ "××– ×ª×©×‘ ×™×•×ª×¨ ×¢× ××©×ª×š"
  âœ… "××™×¤×” ×”×“×¨×š ×”×–×• ××•×‘×™×œ×” ××•×ª×š? ××” ×™×”×™×” ×©×•× ×” ×‘×—×™×™× ×©×œ×š?"
  
  ğŸ“Š Gate Check: ×™×© ×—×–×•×Ÿ ×‘×¨×•×¨ ×•××¢×•×¨×¨ ×”×©×¨××” â†’ ×¢×‘×•×¨ ×œ-S13

- **S13 (××—×•×™×‘×•×ª - ×¤×¢×•×œ×” ×§×•× ×§×¨×˜×™×ª!):**
  ğŸ¯ **××©×™××”:** ××—×•×™×‘×•×ª ×œ×¤×¢×•×œ×” **×¡×¤×¦×™×¤×™×ª ×•×§×•× ×§×¨×˜×™×ª** ×”×‘××”.
  
  **×©××œ×•×ª:**
  1. "××” ×ª×¢×©×”/×™ ××—×¨×ª ×‘×¤×¢× ×”×‘××” ×©×”××¦×‘ ×”×–×” ×™×§×¨×”?"
  2. ×× ×”××©×ª××© × ×•×ª×Ÿ ×ª×©×•×‘×” ×›×œ×œ×™×ª: "×ª×Ÿ/×™ ×œ×™ ×“×•×’××” ×§×•× ×§×¨×˜×™×ª"
  3. "××ª×™ ×–×” ×™×›×•×œ ×œ×§×¨×•×ª?"
  4. "××™×š ×ª×“×¢/×™ ×©××ª×” ××ª×—×™×œ/×” ×œ×¢×©×•×ª ××ª ×–×”?"
  
  **ğŸ›‘ ×—×©×•×‘ ×××•×“:** 
  ×—×™×™×‘×ª ×œ×”×™×•×ª ×¤×¢×•×œ×” **×¡×¤×¦×™×¤×™×ª**, ×œ× ×›×œ×œ×™×ª!
  
  âŒ ×“×•×’×××•×ª ×œ×ª×©×•×‘×•×ª ×œ× ××¡×¤×™×§×•×ª:
  - "×× ×¡×” ×™×•×ª×¨" â†’ ×›×œ×œ×™ ××“×™!
  - "××”×™×” ×™×•×ª×¨ ×§×©×•×‘" â†’ ×œ× ×¡×¤×¦×™×¤×™!
  - "××¢×‘×•×“ ×¢×œ ×–×”" â†’ ××” ×–×” ××•××¨?
  
  âœ… ×“×•×’×××•×ª ×œ×ª×©×•×‘×•×ª ××¦×•×™× ×•×ª:
  - "×‘×¤×¢× ×”×‘××” ×©××©×ª×™ ×ª×“×‘×¨, ×× ×™×— ××ª ×”×˜×œ×¤×•×Ÿ ×”×¦×™×“×” ×•××¡×ª×›×œ ×œ×” ×‘×¢×™× ×™×™×"
  - "×›×©×× ×™ ××¨×’×™×© ×©×× ×™ ××ª×—×™×œ ×œ×’×œ×•×œ ×‘×˜×œ×¤×•×Ÿ, ××¢×¦×•×¨ ×•××©××œ ××•×ª×” '××” ××ª ×¨×•×¦×” ×œ×¡×¤×¨ ×œ×™?'"
  - "×‘×¢×¨×‘×™× ×‘×©×¢×” 8, ××›×‘×” ××ª ×”×˜×œ×¤×•×Ÿ ×œ-30 ×“×§×•×ª ×›×“×™ ×œ×©×‘×ª ××™×ª×”"
  
  ×× ×”××©×ª××© × ×•×ª×Ÿ ×ª×©×•×‘×” ×›×œ×œ×™×ª, ×©××œ:
  "×–×” × ×©××¢ ×˜×•×‘. ×ª×Ÿ/×™ ×œ×™ ×“×•×’××” **×§×•× ×§×¨×˜×™×ª** - ××” **×‘×“×™×•×§** ×ª×¢×©×”?"
  
  ğŸ“Š Gate Check: ×™×© ××—×•×™×‘×•×ª ×§×•× ×§×¨×˜×™×ª ×•×¡×¤×¦×™×¤×™×ª â†’ ğŸ‰ **×¡×™×•× ×”×ª×”×œ×™×š!**
  
  **×¡×™×•×:**
  ××—×¨×™ ×”××—×•×™×‘×•×ª, ×¡×›× ××ª ×›×œ ×”××¡×¢:
  "×ª×•×“×” ×¢×œ ×”××¡×¢ ×”×–×”. ×”×ª×—×œ× ×• ×[× ×•×©×], ×¢×‘×¨× ×• ×“×¨×š [×¨×’×©×•×ª], [××—×©×‘×•×ª], ×–×™×”×™× ×• ××ª [×”×¤×¢×¨], 
   ×•×’×™×œ×™× ×• ××ª ×”×›×•×—×•×ª ×©×œ×š [×¢×¨×›×™× + ×™×›×•×œ×•×ª]. ×¢×›×©×™×• ×™×© ×œ×š ×“×¨×š ×—×“×©×” [×‘×—×™×¨×”] ×©××•×‘×™×œ×” ×œ[×—×–×•×Ÿ], 
   ×•××ª×” ××ª×—×™×™×‘ ×œ[×¤×¢×•×œ×” ×§×•× ×§×¨×˜×™×ª]. ××™×š ×–×” ××¨×’×™×©?"

# ×¤×œ×˜ (Structured Output)
×¢×œ×™×š ×œ×”×—×–×™×¨ ×ª××™×“ ××•×‘×™×™×§×˜ JSON ×”×›×•×œ×œ:
```json
{
  "response": "×”×˜×§×¡×˜ ×”×××¤×ª×™ ×œ××©×ª××© (×¢×‘×¨×™×ª ×˜×‘×¢×™×ª)",
  "internal_state": {
    "current_step": "S1",
    "collected_data": {
      "topic": "×–×•×’×™×•×ª",
      "emotions": ["×›×¢×¡", "×¢×¦×‘"],
      ...
    },
    "saturation_score": 0.7,
    "reflection": "×”××©×ª××© ×¢×“×™×™×Ÿ ×œ× ××•×›×Ÿ ×œ×¢×‘×•×¨ ×œ-S2, ×¦×¨×™×š ×¢×•×“ ×©×”×™×™×”"
  }
}
```

âš ï¸ CRITICAL: 
- ××œ ×ª×›×ª×•×‘ ×˜×§×¡×˜ ×¨×’×™×œ! ×¨×§ JSON!
- ×”-"response" ×—×™×™×‘ ×œ×”×™×•×ª ×˜×‘×¢×™, ×—×, ×× ×•×©×™
- ××œ ×ª×–×›×™×¨ "×©×œ×‘" ××• ××•× ×—×™× ×˜×›× ×™×™× ×œ××©×ª××©
- ××œ ×ª×‘×§×© ×¨×©×™××•×ª ("×ª×Ÿ ×œ×™ 4 ×¨×’×©×•×ª") - ×©××œ "××” ×¢×•×“?"
"""

SYSTEM_PROMPT_EN = """# Identity and Role
You are "Beni", a warm, patient, and empathetic BSD coach ("Return Process").
Your role is not to "solve" problems, but to "hold space" where the coachee discovers answers themselves.

# Core Principle: Shehiya (Staying Power) vs. Haste
**Very Important:** Language models tend to be too efficient. In BSD, efficiency is an obstacle.
- Never ask for lists (e.g., "give me 4 emotions").
- If you identified one emotion, don't move on. Ask "what else?" or "where do you feel it in your body?".
- Create "intentional friction" to prevent the user from escaping to quick solutions.

# Internal Thought Protocol (not shown to user)
Before each response, perform this analysis internally:
1. **Current Stage:** Which stage (S0-S13) am I in based on history?
2. **Saturation Metric:** Has the user truly "stayed" long enough in the current stage? (response length, emotional depth).
3. **Gate Validation:** Have I collected enough data (e.g., 4 emotions in S3) without explicitly asking for it?
4. **Escape Detection:** Is the user trying to jump to solutions? If so, gently return them to observation.

# Conversation Rules
1. **Clean Mirroring:** Repeat user's exact words. If they said "anxiety like a dark cloud", don't interpret as "depression". Ask about the "dark cloud".
2. **No Advice:** Never use "you should", "I suggest" or "try to...". Only ask enabling questions.
3. **Soft Injection:** Use precise questions from the methodology only when user is emotionally ready.
4. **Frustration Detection:** If user expresses confusion, step out of role, explain the value of staying, and ask permission again.

# Stage Structure (for internal enforcement only)
- **S0 (Contract):** Get explicit permission.
- **S1 (Release):** Warm listening to general topic. Don't rush to ask for "specific topic" - let user share at their pace.
- **S2 (Event):** Get one specific moment - **MUST be external interaction with people!**
  
  ğŸš¨ **CRITICAL:** Event must be external interaction (conversation, meeting, conflict), NOT internal process (thought, feeling, consideration).
  
  âœ… Correct: "conversation with spouse", "meeting with boss", "argument with friend"
  âŒ Wrong: "I thought about...", "I felt...", "I was considering..."
  
  If user describes internal thought â†’ redirect: "I hear you thought about [X]. Now take me to an external moment - a conversation with someone - where this came up. Who did you talk to?"
  
  Don't accept "I always..." - ask for "one time recently **with someone**".

- **S3 (Emotion):** Identify 4 emotions. Don't move to S4 until they emerge naturally. Don't ask "what emotions?" - ask "how did you feel?" then "what else?".
- **S4 (Thought):** "What went through your mind at that moment?"
- **S5 (Action - actual):** "What did you actually do?"
- **S6 (Desired):** "What would you want to do/feel/think instead?"
- **S7 (Gap):** Give personal name to gap and rate intensity.
- **S8 (Pattern):** "Does this happen in other places too?"
- **S9 (Stance):** "What do you gain from this stance? What do you lose?"
- **S9 (Forces):** Identify values (source) and abilities (nature).
- **S10 (Choice):** "What new stance do you choose?"
- **S11 (Vision):** "Where does this lead you?"
- **S13 (Commitment):** "What will you do differently next time?"

# Output (Structured Output)
Always return a JSON object with:
```json
{
  "response": "Empathetic text to user (natural language)",
  "internal_state": {
    "current_step": "S1",
    "collected_data": {
      "topic": "relationships",
      "emotions": ["anger", "sadness"],
      ...
    },
    "saturation_score": 0.7,
    "reflection": "User not ready for S2 yet, needs more staying"
  }
}
```

âš ï¸ CRITICAL:
- Don't write regular text! Only JSON!
- "response" must be natural, warm, human
- Don't mention "stage" or technical terms to user
- Don't ask for lists - ask "what else?"
"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SAFETY NETS - Minimal validation to prevent premature transitions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def count_turns_in_step(state: Dict[str, Any], step: str) -> int:
    """
    Count how many coach-user exchanges happened in a specific step.
    
    Returns:
        Number of turns (coach messages) in that step
    """
    count = 0
    for msg in state.get("messages", []):
        is_coach = msg.get("sender") == "coach" or msg.get("role") == "assistant"
        internal = msg.get("internal_state") or msg.get("metadata", {}).get("internal_state", {})
        if is_coach and (internal or {}).get("current_step") == step:
            count += 1
    return count


def detect_stage_question_mismatch(coach_message: str, current_step: str, language: str = "he") -> Optional[str]:
    """
    Detect if coach asked a question from a different stage than current_step.
    This happens when LLM moves forward in content but forgets to update current_step in JSON.
    
    Returns:
        The correct stage if mismatch detected, None otherwise
    """
    if language == "he":
        stage_indicators = {
            "S2": ["××” ×§×¨×”", "××ª×™ ×–×” ×”×™×”", "××™ ×”×™×” ×©×", "××™ ×¢×•×“ ×”×™×”"],
            "S3": ["××” ×”×¨×’×©×ª", "××™×–×” ×¨×’×©", "××™×¤×” ×”×¨×’×©×ª", "××” ×¢×‘×¨ ×‘×š"],
            "S4": ["××” ×¢×‘×¨ ×œ×š ×‘×¨××©", "××” ×—×©×‘×ª", "××” ×××¨×ª ×œ×¢×¦××š"],
            "S5": ["××” ×¢×©×™×ª", "××™×š ×”×’×‘×ª", "××” ×¢×©×™×ª ×‘×¤×•×¢×œ"],
            "S6": ["××” ×”×™×™×ª ×¨×•×¦×”", "××™×š ×”×™×™×ª ×¨×•×¦×” ×œ×”×¨×’×™×©", "××” ×œ×•××¨ ×œ×¢×¦××š"],
            "S7": ["××™×š ×ª×§×¨× ×œ×¤×¢×¨", "×‘×¡×•×œ×", "×›××” ×—×–×§ ×”×¤×¢×¨"],
            "S8": ["××™×¤×” ×¢×•×“", "×××™×¤×” ×¢×•×“", "×”×× ××ª×” ××–×”×”", "×”×× ×–×” ×§×•×¨×”"],
            "S9": ["××” ××ª×” ××¨×•×•×™×—", "××” ××ª×” ××¤×¡×™×“", "××” ×”×”×¤×¡×“", "××” ×”×¨×•×•×—"],
            "S10": ["××™×–×” ×¢×¨×š", "××™×–×• ×™×›×•×œ×ª", "××” ×—×©×•×‘ ×œ×š"],
            "S11": ["××™×–×• ×¢××“×”", "××” ××ª×” ×‘×•×—×¨", "××™×–×• ×‘×—×™×¨×”"]
        }
    else:
        stage_indicators = {
            "S2": ["what happened", "when was", "who was there"],
            "S3": ["what did you feel", "what emotion", "where did you feel"],
            "S4": ["what went through", "what did you think", "what did you tell yourself"],
            "S5": ["what did you do", "how did you respond"],
            "S6": ["what would you want", "how would you want to feel"],
            "S7": ["what would you call", "on a scale", "how strong"],
            "S8": ["where else", "do you recognize", "does this happen"],
            "S9": ["what do you gain", "what do you lose"],
            "S10": ["what value", "what ability", "what's important"],
            "S11": ["what stance", "what do you choose"]
        }
    
    coach_lower = coach_message.lower()
    
    # Check each stage's indicators
    for stage, indicators in stage_indicators.items():
        if any(ind in coach_lower for ind in indicators):
            if stage != current_step:
                logger.error(f"[Stage Mismatch!] Coach asked {stage} question but current_step={current_step}")
                logger.error(f"[Stage Mismatch!] Question: {coach_message[:100]}")
                return stage  # Return the correct stage
    
    return None  # No mismatch detected


def has_clear_topic_for_s2(state: Dict[str, Any]) -> Tuple[bool, str]:
    """
    Minimal safety net: block S1â†’S2 only in extreme cases.
    
    Trust the LLM's judgment. Only block when we have very little content
    (e.g. 1 short message like "×¢×œ ×©××—×”" with no context).
    
    Returns:
        (has_clear_topic, reason_if_not)
    """
    messages = state.get("messages", [])
    recent_user_msgs = [
        msg.get("content", "").strip()
        for msg in messages[-8:]
        if msg.get("sender") == "user" and msg.get("content", "").strip()
    ]
    
    # Block only if: 1 message or less, OR total content very short
    if len(recent_user_msgs) < 2:
        return False, "need_more_clarification"
    
    total_length = sum(len(msg) for msg in recent_user_msgs)
    if total_length < 30:
        return False, "too_vague"
    
    return True, ""


def get_s1_explanation_for_missing_info(reason: str, language: str) -> str:
    """
    Generate explanatory response when user is frustrated in S1 but topic is not clear enough.
    
    User asked "what's missing?" - explain WHY we need more clarity.
    """
    if language == "he":
        explanations = {
            "need_more_clarification": (
                "×× ×™ ××‘×™×Ÿ ××ª ×”×©××œ×”. ×× ×™ ×©×•××œ ×¢×•×“ ×›×™ **×¦×¨×™×š ×©×”× ×•×©× ×™×”×™×” ××•×’×“×¨ ×”×™×˜×‘** ×œ×¤× ×™ ×©× ××©×™×š. "
                "×›×“×™ ×œ×–×”×•×ª ××ª ×”×“×¤×•×¡ ×©×œ×š, ×× ×™ ×¦×¨×™×š ×œ×”×‘×™×Ÿ ×‘××“×•×™×§ ×¢×œ ××” ××ª×” ×¨×•×¦×” ×œ×”×ª×××Ÿ. "
                "××” **×‘×“×™×•×§** ×‘× ×•×©× ×”×–×” ××¢×¡×™×§ ××•×ª×š? ×‘××” ××ª×” ××¨×’×™×© ×ª×§×•×¢?"
            ),
            "too_vague": (
                "×× ×™ ××‘×™×Ÿ ×©××ª×” ×¨×•×¦×” ×œ×”××©×™×š. ×× ×™ ×©×•××œ ×¢×•×“ ×›×™ **×”× ×•×©× ×¢×“×™×™×Ÿ ×›×œ×œ×™ ××“×™**. "
                "×›×“×™ ×œ×¢×–×•×¨ ×œ×š ×‘×××ª, ×× ×™ ×¦×¨×™×š ×œ×”×‘×™×Ÿ - ×‘××™×–×” **××¦×‘×™× ×¡×¤×¦×™×¤×™×™×** ××• **×”×§×©×¨×™×** "
                "×”×“×‘×¨ ×”×–×” ××¢×¡×™×§ ××•×ª×š ×‘××™×•×—×“?"
            ),
            "missing_context": (
                "×× ×™ ×©×•××¢ ××•×ª×š. ×× ×™ ××‘×§×© ×¢×•×“ ×”×‘×”×¨×” ×›×™ **×—×¡×¨ ×œ×™ ×”×§×©×¨**. "
                "×›×“×™ ×©× ×•×›×œ ×œ×–×”×•×ª ××ª ×”×“×¤×•×¡ ×©×œ×š, ×—×©×•×‘ ×©××‘×™×Ÿ - "
                "**×¢× ××™** ××• **×‘××™×–×” ×¡×™×˜×•××¦×™×•×ª** ×–×” ××¢×¡×™×§ ××•×ª×š ×‘××™×•×—×“?"
            )
        }
        return explanations.get(reason, explanations["missing_context"])
    else:
        explanations = {
            "need_more_clarification": (
                "I understand you want to continue. "
                "The reason I'm asking for more clarification is that to identify your pattern, "
                "I need to understand exactly what you want to work on. "
                "Tell me - what specifically concerns you about this topic?"
            ),
            "too_vague": (
                "I understand. "
                "To really help you, I need to understand more deeply - "
                "in what situation or context does this concern you?"
            ),
            "missing_context": (
                "I hear you. "
                "To identify your pattern, it's important I understand - "
                "in what situations or with whom does this particularly concern you?"
            )
        }
        return explanations.get(reason, explanations["missing_context"])


def get_next_step_question(current_step: str, language: str = "he") -> str:
    """
    Get appropriate next question based on current step (for loop prevention).
    
    Instead of always jumping to S4, this returns the right question for progression.
    """
    if language == "he":
        step_questions = {
            "S0": "×¢×œ ××” ×ª×¨×¦×” ×œ×”×ª×××Ÿ?",
            "S1": "×¡×¤×¨ ×œ×™ ×¢×œ ×¤×¢× ××—×ª ×¡×¤×¦×™×¤×™×ª ×©×‘×• ×–×” ×§×¨×” - ××ª×™ ×–×” ×”×™×”?",  # Move to S2!
            "S2": "×¡×¤×¨ ×œ×™ ×¢×œ ×¨×’×¢ ××—×“ ×¡×¤×¦×™×¤×™ ×©×‘×• ×–×” ×§×¨×” - ××ª×™ ×–×” ×”×™×”?",
            "S3": "×× ×™ ××‘×™×Ÿ. ×¢×›×©×™×• ×× ×™ ×¨×•×¦×” ×œ×©××•×¢ - ××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢?",
            "S4": "××” ×¢×©×™×ª ×‘××•×ª×• ×¨×’×¢?",
            "S5": "××” ×¢×©×™×ª ×‘×¤×•×¢×œ? ××™×š ×”×’×‘×ª?",
            "S6": "××” ×”×™×™×ª ×¨×•×¦×” ×œ×¢×©×•×ª ×‘××§×•×? ××™×š ×œ×”×¨×’×™×©? ××” ×œ×•××¨ ×œ×¢×¦××š?",
            "S7": "××™×š ×ª×§×¨× ×œ×¤×¢×¨ ×”×–×”? ×ª×Ÿ ×œ×• ×©× ××©×œ×š.",
            "S8": "××™×¤×” ×¢×•×“ ×–×” ×§×•×¨×”?",
            "S9": "××” ××ª×” ××¨×•×•×™×— ××”×“×¤×•×¡ ×”×–×”?",
            "S10": "××” ×—×©×•×‘ ×œ×š ×‘×—×™×™×? ××™×–×” ×¢×¨×š?",
            "S11": "××™×–×• ×¢××“×” ×—×“×©×” ××ª×” ×‘×•×—×¨?",
            "S12": "××™×¤×” ×”×‘×—×™×¨×” ×”×–×• ××•×‘×™×œ×” ××•×ª×š?",
            "S13": "××” ×ª×¢×©×” ×‘×¤×¢× ×”×‘××”?"
        }
    else:
        step_questions = {
            "S0": "What would you like to work on?",
            "S1": "Tell me about one specific time when this happened - when was it?",  # Move to S2!
            "S2": "Tell me about one specific moment when this happened - when was it?",
            "S3": "I understand. Now I want to hear - what went through your mind in that moment?",
            "S4": "What did you do in that moment?",
            "S5": "What did you actually do? How did you respond?",
            "S6": "What would you have wanted to do instead? How to feel? What to tell yourself?",
            "S7": "What would you call this gap? Give it a name.",
            "S8": "Where else does this happen?",
            "S9": "What do you gain from this pattern?",
            "S10": "What's important to you in life? What value?",
            "S11": "What new stance do you choose?",
            "S12": "Where does this choice lead you?",
            "S13": "What will you do next time?"
        }
    
    return step_questions.get(current_step, "×‘×•× × ××©×™×š ×”×œ××”." if language == "he" else "Let's continue.")


def detect_re_asking_for_event(
    coach_message: str,
    state: Dict[str, Any],
    language: str = "he"
) -> Optional[Tuple[str, str]]:
    """
    If coach asks for event again but user already gave full event - override with
    the *next valid stage question* (usually S3 from S2).
    Prevents the "×¡×¤×¨×ª×™ ×œ×š ×¢×œ ×”×¨×’×¢ ×‘××’×¨×©" loop.
    """
    current_step = state.get("current_step", "")
    if current_step not in ("S2", "S3"):
        return None
    coach_lower = coach_message.lower()
    event_asking_phrases = [
        "××™×¨×•×¢ ×¡×¤×¦×™×¤×™", "×ª×™×§×— ××•×ª×™ ×œ×¨×’×¢", "×¡×¤×¨ ×œ×™ ×¢×œ ××™×¨×•×¢",
        "×¤×¢× ××—×ª ×¡×¤×¦×™×¤×™×ª", "×¨×’×¢ ××¡×•×™× ×©×‘×•", "××ª×™ ×–×” ×”×™×”", "×¢× ××™ ×–×” ×”×™×”"
    ]
    if not any(p in coach_lower for p in event_asking_phrases):
        return None
    has_event, _ = has_sufficient_event_details(state)
    if not has_event:
        return None
    current_step = state.get("current_step", "S2")
    logger.warning(f"[Safety Net] Coach re-asking for event but user already gave it - overriding with stage-aware next question")

    if current_step == "S2":
        if language == "he":
            return (
                "××¦×˜×¢×¨ ×¢×œ ×”×—×–×¨×”! ×©××¢×ª×™ ××ª ×”××™×¨×•×¢. ×¢×›×©×™×• ×‘×•× × ×™×›× ×¡ ×¤× ×™××” ×œ×¨×’×¢ ×”×–×” - ××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?",
                "S3",
            )
        return (
            "Sorry for repeating! I heard the event. Now let's go into that moment - what did you feel right then?",
            "S3",
        )

    # If we're already in S3 and still got an event-reask, move to S4 question.
    if language == "he":
        return (
            "××¦×˜×¢×¨ ×¢×œ ×”×—×–×¨×”! ×›×‘×¨ ×™×© ×œ× ×• ××ª ×”××™×¨×•×¢. ×¢×›×©×™×• ×× ×™ ×¨×•×¦×” ×œ×”×‘×™×Ÿ - ××” ×¢×‘×¨ ×œ×š ×‘×¨××© ×‘××•×ª×• ×¨×’×¢?",
            "S4",
        )
    return (
        "Sorry for repeating! We already have the event. Now I want to understand - what went through your mind in that moment?",
        "S4",
    )


def check_repeated_question(coach_message: str, history: list, current_step: str, language: str = "he") -> Optional[str]:
    """
    Check if coach is repeating a question that was already answered or sent recently.
    
    Returns:
        Correction message if repeating, None otherwise
    """
    # Get recent messages
    recent_coach_messages = [
        msg.get("content", "") for msg in history[-8:]
        if msg.get("sender") in ["coach", "assistant"]
    ]
    
    recent_user_messages = [
        msg.get("content", "").lower() for msg in history[-4:]
        if msg.get("sender") == "user"
    ]
    
    # === CRITICAL: S1 + emotions question = wrong stage! Block immediately ===
    if current_step == "S1":
        emotions_indicators_he = ["××” ×”×¨×’×©×ª", "××™×–×” ×¨×’×©", "×œ×”×ª×¢××§ ×‘×¨×’×©×•×ª", "××” ×¢×‘×¨ ×‘×š", "××™×¤×” ×”×¨×’×©×ª"]
        emotions_indicators_en = ["what did you feel", "what emotion", "delve into emotions", "how did you feel"]
        indicators = emotions_indicators_he if language == "he" else emotions_indicators_en
        coach_lower = coach_message.lower()
        if any(ind in coach_lower for ind in indicators):
            _bsd_log("REPETITION_RULE", rule="S1_emotions_question", step=current_step)
            logger.warning(f"[Safety Net] S1 but coach asked emotions question - BLOCKING (no event yet!)")
            return get_next_step_question(current_step, language)
    
    if language == "he":
        # === CRITICAL: Check if user said they're done ===
        import re
        
        # Phrases (can appear anywhere)
        completion_phrases = [
            "×–×” ××¡×›×", "×–×” ×”×›×œ", "×›×œ ×”×¨×’×©×•×ª", "×–×” ×›×œ ×”×¨×’×©×•×ª",
            "×“×™ ×œ×™", "×›×‘×¨ ×›×ª×‘×ª×™", "×××¨×ª×™ ××ª ×›×œ", "×–×” ××¡×¤×™×§", 
            "×¡×™×™××ª×™", "×–×” ××” ×©×™×©", "××™×Ÿ ×™×•×ª×¨", "××™×Ÿ ×¢×•×“",
            # NEW: From infinite loop bug analysis
            "×œ× ×§×¨×” ×›×œ×•×", "×œ× ×§×¨×” ×©×•× ×“×‘×¨", "×œ× ×”×™×” ×›×œ×•×",
            "×›×ª×‘×ª×™ ×œ×š", "×××¨×ª×™ ×œ×š", "×¢× ×™×ª×™ ×›×‘×¨", "×¢× ×™×ª×™ ×¢×œ ×–×”",
            "××” ×¢×›×©×™×•", "××•×œ×™ × ××©×™×š", "×‘×•× × ××©×™×š"
        ]
        
        # Short words (need word boundaries)
        completion_words = ["×–×”×•", "×“×™", "××¡×¤×™×§", "×”×›×œ"]
        
        user_said_done = any(
            any(phrase in msg for phrase in completion_phrases) or
            any(re.search(rf'\b{word}\b', msg) for word in completion_words)
            for msg in recent_user_messages
        )
        
        # === Check for "××” ×¢×•×“?" variants (most common loop) ===
        asking_what_else = any(
            pattern in coach_message.lower()
            for pattern in ["××” ×¢×•×“", "×¢×•×“ ××©×”×•", "××” × ×•×¡×£"]
        )
        
        # Count how many "××” ×¢×•×“?" questions in recent history
        what_else_count = sum(
            1 for msg in recent_coach_messages
            if any(pattern in msg for pattern in ["××” ×¢×•×“", "×¢×•×“ ××©×”×•"])
        )
        
        # If user said done + coach asking "what else?" again = LOOP!
        if user_said_done and asking_what_else:
            _bsd_log("REPETITION_RULE", rule="user_said_done_but_what_else", step=current_step)
            logger.warning(f"[Safety Net] User said done, but coach asking '××” ×¢×•×“?' - BLOCKING")
            return get_next_step_question(current_step, language)
        
        # If "××” ×¢×•×“?" asked 3+ times = LOOP!
        if what_else_count >= 3:
            _bsd_log("REPETITION_RULE", rule="what_else_3plus", count=what_else_count, step=current_step)
            logger.warning(f"[Safety Net] '××” ×¢×•×“?' asked {what_else_count} times - BLOCKING")
            return get_next_step_question(current_step, language)
        
        # === Check if coach is sending the EXACT same message again ===
        if coach_message in recent_coach_messages[-2:]:
            _bsd_log("REPETITION_RULE", rule="exact_repeat", step=current_step)
            logger.warning(f"[Safety Net] Detected EXACT repeated message")
            return get_next_step_question(current_step, language)
        
        # === Generic patterns (S1 loop: "×ª×•×›×œ ×œ×¡×¤×¨ ×œ×™ ×™×•×ª×¨" etc.) ===
        generic_patterns = [
            "×¡×¤×¨ ×œ×™ ×¢×•×“ ×¢×œ ×”×¨×’×¢ ×”×–×”",
            "××” ×‘×“×™×•×§ ×§×¨×”",
            "×¡×¤×¨ ×œ×™ ×™×•×ª×¨ ×¢×œ",
            "×ª×•×›×œ ×œ×¡×¤×¨ ×œ×™ ×™×•×ª×¨",
            "×ª×•×›×œ ×œ×¡×¤×¨ ×œ×™ ×™×•×ª×¨ ×¢×œ",
            "××” ×‘×“×™×•×§ ×‘"
        ]
        
        generic_count = sum(
            1 for msg_content in recent_coach_messages
            if any(pattern in msg_content for pattern in generic_patterns)
        )
        
        # S1: trigger after 2 (not 3) - catch loop earlier
        threshold = 2 if current_step == "S1" else 3
        if generic_count >= threshold:
            _bsd_log("REPETITION_RULE", rule="generic_patterns", count=generic_count, threshold=threshold, step=current_step)
            logger.warning(f"[Safety Net] Too many generic questions ({generic_count})")
            return get_next_step_question(current_step, language)
    
    else:  # English
        # Check if user said they're done
        completion_keywords = [
            "that's all", "that's it", "all the", "i'm done",
            "that's everything", "nothing else", "no more",
            # NEW: From infinite loop bug analysis
            "nothing happened", "nothing else happened",
            "i told you", "already told", "already answered",
            "what now", "let's continue", "let's move on"
        ]
        
        user_said_done = any(
            keyword in msg for msg in recent_user_messages
            for keyword in completion_keywords
        )
        
        asking_what_else = any(
            pattern in coach_message.lower()
            for pattern in ["what else", "anything else", "what more"]
        )
        
        what_else_count = sum(
            1 for msg in recent_coach_messages
            if "what else" in msg.lower() or "anything else" in msg.lower()
        )
        
        if user_said_done and asking_what_else:
            logger.warning(f"[Safety Net] User said done, but coach asking 'what else?' - BLOCKING")
            return get_next_step_question(current_step, language)
        
        if what_else_count >= 3:
            logger.warning(f"[Safety Net] 'What else?' asked {what_else_count} times - BLOCKING")
            return get_next_step_question(current_step, language)
        
        if coach_message in recent_coach_messages[-2:]:
            logger.warning(f"[Safety Net] Detected EXACT repeated message")
            return get_next_step_question(current_step, language)
        
        # === Generic patterns (English S1 loop) ===
        generic_patterns_en = [
            "tell me more about",
            "can you tell me more",
            "what exactly about",
            "what specifically"
        ]
        generic_count = sum(
            1 for msg_content in recent_coach_messages
            if any(pattern in msg_content.lower() for pattern in generic_patterns_en)
        )
        threshold = 2 if current_step == "S1" else 3
        if generic_count >= threshold:
            logger.warning(f"[Safety Net] Too many generic questions ({generic_count})")
            return get_next_step_question(current_step, language)
    
    return None


async def user_already_gave_emotions_llm(state: Dict[str, Any], llm, language: str = "he") -> bool:
    """
    Use LLM to detect if user already shared emotions (smart detection).
    More accurate than keyword list - detects "×¨×¢", "×—× ×•×§", "×œ× ×˜×‘×¢×™", etc.
    """
    messages = state.get("messages", [])
    recent_user_messages = [
        msg.get("content", "")
        for msg in messages[-6:]
        if msg.get("sender") == "user" and msg.get("content")
    ]
    
    if not recent_user_messages:
        return False
    
    if language == "he":
        prompt = f"""×”×× ×‘××¡×¨×™× ×”×‘××™× ×”××©×ª××© ×©×™×ª×£ ×¨×’×©×•×ª?

×¨×’×©×•×ª = ×›×¢×¡, ×¢×¦×‘, ×©××—×”, ×¤×—×“, ×§× ××”, ×ª×¡×›×•×œ, ×¨×¢, ×˜×•×‘, ×—× ×•×§, × ×–×”×¨, ×—×¡×•×, ×•×›×•'

××¡×¨×™×:
{chr(10).join(f"- {msg}" for msg in recent_user_messages)}

×¢× ×” ×¨×§: ×›×Ÿ ××• ×œ×"""
    else:
        prompt = f"""Did the user share emotions in the following messages?

Emotions = anger, sadness, joy, fear, jealousy, frustration, bad, good, stuck, scared, etc.

Messages:
{chr(10).join(f"- {msg}" for msg in recent_user_messages)}

Answer only: yes or no"""
    
    try:
        detection_messages = [
            SystemMessage(content="You detect emotions in text." if language == "en" else "××ª×” ××–×”×” ×¨×’×©×•×ª ×‘×˜×§×¡×˜."),
            HumanMessage(content=prompt)
        ]
        
        response = await _ainvoke_with_prompt_cache(
            llm,
            detection_messages,
            cache_key=f"{os.getenv('AZURE_OPENAI_PROMPT_CACHE_KEY_PREFIX', 'bsd_v2')}:emotion_detection:{language}",
        )
        answer = response.content.strip().lower()
        
        has_emotions = "×›×Ÿ" in answer or "yes" in answer
        logger.info(f"[Emotion Detection] LLM detected emotions: {has_emotions}")
        return has_emotions
        
    except Exception as e:
        logger.error(f"[Emotion Detection] LLM call failed: {e}")
        # Fallback to simple keyword check
        return user_already_gave_emotions_simple(state)


def user_already_gave_emotions_simple(state: Dict[str, Any], last_turns: int = 3) -> bool:
    """
    Fallback: Simple keyword-based emotion detection.
    Used if LLM detection fails.
    """
    emotion_keywords_he = [
        "×§× ××”", "×›×¢×¡", "×¢×¦×‘", "×©××—×”", "×¤×—×“", "×ª×¡×›×•×œ", "××›×–×‘×”",
        "×’××•×•×”", "×‘×•×©×”", "××©×", "××‘×•×›×”", "×¢×œ×‘×•×Ÿ", "× ×™×¦×•×œ",
        # Extended list
        "×¨×¢", "×˜×•×‘", "×—× ×•×§", "× ×–×”×¨", "×œ× ×˜×‘×¢×™", "××ª×•×—", "×œ×—×•×¥",
        "××‘×•×œ×‘×œ", "××•×¤×ª×¢", "× ×¢×œ×‘", "××•×˜×¨×“", "×“××•×’",
        "×”×¨×’×©×ª×™", "××¨×’×™×©"
    ]
    emotion_keywords_en = [
        "jealous", "anger", "sad", "happy", "fear", "frustrat",
        "disappoint", "proud", "shame", "guilt", "embarrass",
        "bad", "good", "stuck", "scared", "nervous", "worried",
        "felt", "feeling"
    ]
    
    messages = state.get("messages", [])
    recent_user_messages = [
        msg.get("content", "").lower() 
        for msg in messages[-last_turns * 2:] 
        if msg.get("sender") == "user" and msg.get("content")
    ]
    
    for msg in recent_user_messages:
        if any(emotion in msg for emotion in emotion_keywords_he):
            return True
        if any(emotion in msg for emotion in emotion_keywords_en):
            return True
    
    return False


def user_already_gave_emotions(state: Dict[str, Any], last_turns: int = 3) -> bool:
    """
    Synchronous wrapper for backwards compatibility.
    Uses simple keyword detection.
    
    For better detection, use user_already_gave_emotions_llm() in async context.
    """
    return user_already_gave_emotions_simple(state, last_turns)


def detect_stuck_loop(state: Dict[str, Any], last_n: int = 4) -> bool:
    """
    Detect if coach is stuck repeating the same question.
    """
    messages = state.get("messages", [])
    recent_coach = [
        msg.get("content", "")
        for msg in messages[-last_n:]
        if msg.get("sender") == "coach" and msg.get("content")
    ]
    
    if len(recent_coach) < 2:
        return False
    
    # Check exact repetition
    if recent_coach[-1] == recent_coach[-2]:
        logger.warning(f"[Loop Detection] Exact repetition detected!")
        return True
    
    # Check similar questions
    key_phrases = ["××” ×¢×•×“ ×§×¨×”", "××” ×”×¨×’×©×ª", "what else happened", "what did you feel"]
    for phrase in key_phrases:
        count = sum(1 for msg in recent_coach if phrase in msg)
        if count >= 2:
            logger.warning(f"[Loop Detection] Repeated question detected: '{phrase}' x{count}")
            return True
    
    return False


def count_pattern_examples_in_s7(state: Dict[str, Any]) -> int:
    """
    Count how many pattern examples user gave in S7 (by content, not just turns).
    """
    messages = state.get("messages", [])
    
    # Get user messages (approximate S7 by looking at recent messages)
    user_msgs = [
        msg.get("content", "")
        for msg in messages[-12:]
        if msg.get("sender") == "user" and msg.get("content")
    ]
    
    if not user_msgs:
        return 0
    
    all_text = " ".join(user_msgs)
    example_count = 0
    
    # Method 1: Count explicit example markers
    example_count += all_text.count("×œ××©×œ")
    example_count += all_text.count("×’×")
    example_count += all_text.count("×•×’×")
    
    # Method 2: Count location/context indicators
    # "×¢× ×—×‘×¨×™×", "×‘×¢×‘×•×“×”", "×¢× ×‘×Ÿ ×”×–×•×’"
    context_patterns = [
        "×¢× ×—×‘×¨×™×", "×¢× ××©×¤×—×”", "×¢× ×‘×Ÿ ×”×–×•×’", "×¢× ××™×©×ª×™", "×¢× ×‘×¢×œ×™",
        "×‘×¢×‘×•×“×”", "×‘×‘×™×ª", "×‘××©×¨×“", "×‘×¤×’×™×©×”",
        "with friends", "with family", "at work", "at home"
    ]
    
    for pattern in context_patterns:
        if pattern in all_text:
            example_count += 1
    
    # Method 3: Check if user explicitly said multiple places
    multiple_indicators = [
        "×‘×”×¨×‘×” ××§×•××•×ª", "×‘×›×œ ××§×•×", "×‘×”××•×Ÿ", "×‘×›××”",
        "in many places", "everywhere", "in multiple"
    ]
    
    if any(ind in all_text for ind in multiple_indicators):
        example_count += 2  # "many places" = at least 2 examples
    
    logger.info(f"[Pattern Examples] Counted {example_count} examples in S7")
    return example_count


def user_said_already_gave_examples(user_message: str) -> bool:
    """Check if user explicitly said they already gave examples"""
    phrases_he = [
        "×××¨×ª×™ ×›×‘×¨", "×›×‘×¨ ×××¨×ª×™", "×›×‘×¨ × ×ª×ª×™",
        "×–×” ××•×¤×™×¢ ×‘", "×–×” ×§×•×¨×” ×‘",
        "×××¨×ª×™ ×œ×š"
    ]
    phrases_en = [
        "i already said", "already told", "already gave",
        "it happens in", "it occurs in"
    ]
    
    msg_lower = user_message.lower()
    return any(p in msg_lower for p in phrases_he + phrases_en)


async def validate_situation_quality(state: Dict[str, Any], llm, language: str = "he") -> Tuple[bool, Optional[str]]:
    """
    Validate that the situation (S2) meets basic criteria using FAST rule-based checks.
    We rely on the LLM's prompt instructions for detailed validation to avoid double LLM calls.
    
    This function only performs lightweight checks to catch obvious issues.
    
    Returns:
        (is_valid, guidance_message_if_invalid)
    """
    messages = state.get("messages", [])
    
    # Get user messages from S2
    user_msgs_s2 = [
        msg.get("content", "")
        for msg in messages[-20:]
        if msg.get("sender") == "user" and msg.get("content")
    ]
    
    if len(user_msgs_s2) < 2:
        # Not enough data yet
        return True, None
    
    situation_text = "\n".join(user_msgs_s2[-5:])  # Last 5 user messages
    situation_lower = situation_text.lower()
    
    # FAST rule-based checks (no LLM call!)
    
    # Check 1: Basic length (too short = not enough details)
    if len(situation_text) < 50:
        logger.info(f"[Situation Validation] Too short ({len(situation_text)} chars)")
        return True, None  # Let LLM handle it
    
    # Check 2: "I was alone" = no interpersonal arena
    alone_indicators = ["×”×™×™×ª×™ ×œ×‘×“", "×”×™×™×ª×™ ×‘×‘×™×ª ×œ×‘×“", "×œ×‘×“ ×‘×‘×™×ª", "i was alone", "by myself", "all alone"]
    if any(ind in situation_lower for ind in alone_indicators):
        logger.info(f"[Situation Validation] Detected 'alone' situation - needs interpersonal")
        if language == "he":
            return False, """×× ×™ ××‘×™×Ÿ ××ª ×”×—×•×•×™×” ×©×ª×™××¨×ª. ×›×“×™ ×œ×–×”×•×ª ×“×¤×•×¡ ×× ×—× ×• ××—×¤×©×™× ××™×¨×•×¢ ×©×”×™×• ××¢×•×¨×‘×™× ×‘×• ×× ×©×™× × ×•×¡×¤×™× ××œ×‘×“×™×š.

×‘×•× × × ×¡×” ××©×”×• ××—×¨ - ×¡×¤×¨ ×œ×™ ×¢×œ **××™×¨×•×¢ ××”×—×™×™× ×©×œ×š** (×™×›×•×œ ×œ×”×™×•×ª ××”×¢×‘×•×“×”, ×¢× ×—×‘×¨×™×, ×¢× ××©×¤×—×”, ×‘×›×œ ××¦×‘) ×©×‘×• ×”×™×• ×× ×©×™× ××—×¨×™× ×•×—×•×•×™×ª ×¡×¢×¨×” ×¨×’×©×™×ª.

**×—×©×•×‘:** ×”××™×¨×•×¢ ×œ× ×—×™×™×‘ ×œ×”×™×•×ª ×§×©×•×¨ ×œ× ×•×©× ×”××™××•×Ÿ - ×”×“×¤×•×¡ ×©×œ×š ××ª×’×œ×” ×‘×›×œ ×ª×—×•××™ ×”×—×™×™×, ×•×œ×¤×¢××™× ×“×•×•×§× ×‘××™×¨×•×¢ ××ª×—×•× ××—×¨ ×œ×’××¨×™."""
        else:
            return False, "I understand the experience you described. To identify a pattern we're looking for an event where other people were involved besides you. Let's try something else - tell me about **an event from your life** (can be from work, with friends, with family, any situation) where other people were present and you experienced emotional turmoil. **Important:** The event doesn't have to be related to the coaching topic - your pattern shows up in all areas of life, sometimes most clearly in a completely different area."
    
    # All basic checks passed - let the LLM prompt handle detailed validation
    logger.info(f"[Situation Validation] Basic checks passed (fast mode, no LLM call)")
    return True, None


def user_questions_unrelated_event(user_message: str) -> bool:
    """
    Check if user is asking why the event doesn't have to be related to coaching topic.
    """
    questions_he = [
        "×œ××” ×œ×", "×œ××” ××™×¨×•×¢", "×œ××” ×¡×™×˜×•××¦×™×”", "×œ××” ×“×•×•×§×",
        "××” ×”×§×©×¨", "×¦×¨×™×š ×œ×”×™×•×ª ×§×©×•×¨", "×œ× ×§×©×•×¨",
        "××™×¨×•×¢ ××—×¨", "××™×¨×•×¢ ×©×œ×", "×œ××” ×œ× ×§×©×•×¨"
    ]
    questions_en = [
        "why not", "why event", "why situation",
        "what's the connection", "needs to be related", "not related",
        "different event", "unrelated event"
    ]
    
    msg_lower = user_message.lower()
    return any(q in msg_lower for q in questions_he + questions_en)


def user_wants_to_continue(user_message: str) -> bool:
    """
    Check if user is signaling they want to move forward.
    Indicators: "already told you", "let's continue", "nothing happened"
    
    NOTE: This is just an INDICATOR. Don't automatically allow transition!
    Check if we have sufficient info first, then explain if not.
    """
    continue_signals = [
        # Hebrew
        "×›×ª×‘×ª×™ ×œ×š", "×××¨×ª×™ ×œ×š", "×¢× ×™×ª×™", "×›×‘×¨ ×××¨×ª×™",
        "×œ× ×§×¨×” ×›×œ×•×", "×œ× ×§×¨×” ×©×•× ×“×‘×¨", "×œ× ×”×™×”",
        "××•×œ×™ × ××©×™×š", "×‘×•× × ××©×™×š", "××” ×¢×›×©×™×•",
        "×–×”×•", "×“×™", "××™×Ÿ ×¢×•×“",
        
        # English
        "i told you", "already said", "already answered",
        "nothing happened", "nothing else",
        "let's continue", "let's move on", "what now"
    ]
    
    msg_lower = user_message.lower()
    return any(signal in msg_lower for signal in continue_signals)


def _check_event_criteria_bsd(state: Dict[str, Any], language: str = "he") -> Tuple[bool, List[str]]:
    """
    BSD methodology: ××™×¨×•×¢ ××¤×•×¨×˜ = ××ª×™ + ××™×¤×” + ××™ + ××” ×§×¨×”.
    Returns (has_sufficient, list of missing: "××ª×™"|"××™×¤×”"|"××™"|"××”").
    """
    collected = state.get("collected_data") or {}
    event_desc = collected.get("event_description") or ""
    messages = state.get("messages", [])
    recent_user = [
        msg.get("content", "")
        for msg in messages[-10:]
        if (msg.get("sender") == "user" or msg.get("role") == "user") and msg.get("content")
    ]
    all_text = " ".join(recent_user).lower() if recent_user else ""

    # Fast path: LLM extracted structured event
    if event_desc and len(event_desc.strip()) >= 40:
        return True, []

    if len(recent_user) < 2:
        return False, ["××ª×™", "××™×¤×”", "××™", "××”"]

    missing: List[str] = []

    # ××ª×™ - ××¡×’×¨×ª ×–××Ÿ ×¡×¤×¦×™×¤×™×ª (×œ× "×›×©×× ×™ ×œ×—×•×¥" - ×–×” ×ª× ××™, ×œ× ×–××Ÿ)
    mati_he = ["××ª××•×œ", "×©×‘×•×¢×™×™×", "×œ×¤× ×™ ×©×‘×•×¢", "×œ×¤× ×™ ×—×•×“×©", "×‘×™×•× ×©×™×©×™", "×‘×©×‘×•×¢ ×©×¢×‘×¨", "×‘×—×•×“×© ×©×¢×‘×¨", "×œ× ××–××Ÿ", "×œ××—×¨×•× ×”"]
    mati_en = ["yesterday", "last week", "last month", "a few weeks", "recently"]
    mati_ok = any(p in all_text for p in mati_he) or any(p in all_text for p in mati_en)
    if not mati_ok:
        missing.append("××ª×™")

    # ××™×¤×” - ××™×§×•×/×–×™×¨×”
    eyfa_he = ["×‘×‘×™×ª", "×‘×—×“×¨", "×‘×¡×œ×•×Ÿ", "×‘×¢×‘×•×“×”", "×‘××©×¨×“", "×‘×¤×’×™×©×”", "×‘××•×˜×•", "×‘××˜×‘×—", "×‘×›× ×™×¡×”"]
    eyfa_en = ["at home", "at work", "in the", "in a meeting"]
    eyfa_ok = any(p in all_text for p in eyfa_he) or any(p in all_text for p in eyfa_en)
    if not eyfa_ok:
        missing.append("××™×¤×”")

    # ××™ - ×× ×©×™× ××¢×•×¨×‘×™× (×œ× "×× ×™" ×œ×‘×“)
    mi_he = ["××©×ª×™", "×‘×¢×œ×™", "×‘×Ÿ ", "×‘×ª ", "×—×‘×¨", "×¢××™×ª", "×× ×”×œ", "×‘×•×¡", "×™×œ×“×™×", "××©×¤×—×”", "×¢× ", "××™×ª×”", "××™×ª×•"]
    mi_en = ["wife", "husband", "son", "daughter", "friend", "boss", "manager", "with "]
    mi_ok = any(p in all_text for p in mi_he) or any(p in all_text for p in mi_en)
    if not mi_ok:
        missing.append("××™")

    # ××” - ××” ×§×¨×” (××™× ×˜×¨××§×¦×™×”, ×“×™××œ×•×’, ×ª×’×•×‘×”)
    ma_he = ["×§×¨×”", "×××¨", "×××¨×”", "×©××œ", "×”×’×™×‘", "× ×××¨", "× ×¤×’×¢", "×“×™×‘×¨× ×•", "×©×™×—×”", "××¨×™×‘×”", "×¨××™×ª×™", "×©××¢×ª×™", "××ª×™×™×—×¡"]
    ma_en = ["said", "asked", "happened", "told", "talked", "argued", "saw", "heard"]
    ma_ok = any(p in all_text for p in ma_he) or any(p in all_text for p in ma_en)
    if not ma_ok:
        missing.append("××”")

    # BSD: ×× ×™×© 3+ ×-4 = ××¡×¤×™×§ (×’××™×©×•×ª ×¡×‘×™×¨×”)
    has_enough = (mati_ok and mi_ok and ma_ok) or (eyfa_ok and mi_ok and ma_ok)
    if has_enough:
        return True, []
    return False, missing if missing else ["××ª×™", "××™×¤×”", "××™", "××”"]


def has_sufficient_event_details(state: Dict[str, Any]) -> Tuple[bool, str]:
    """
    Check if we have enough event details per BSD: ××ª×™, ××™×¤×”, ××™, ××” ×§×¨×”.
    Returns (has_sufficient, reason_if_not) - reason is comma-separated missing criteria.
    """
    has_enough, missing = _check_event_criteria_bsd(state)
    if has_enough:
        return True, ""
    if not missing:
        return False, "need_more_responses"
    return False, ",".join(missing)


def get_explanatory_response_for_missing_details(reason: str, language: str) -> str:
    """
    BSD-aligned: ask TARGETED questions based on what's missing (××ª×™, ××™×¤×”, ××™, ××”).
    """
    missing = [m.strip() for m in reason.split(",") if m.strip()] if reason else []
    if not missing:
        missing = ["××ª×™", "××™×¤×”", "××™", "××”"]

    if language == "he":
        # ×©××œ×•×ª ×××•×§×“×•×ª ×œ×¤×™ ××” ×©×—×¡×¨ (BSD: ××ª×™, ××™×¤×”, ××™, ××”)
        q = []
        if "××ª×™" in missing:
            q.append("××ª×™ ×–×” ×”×™×” ×œ××—×¨×•× ×”? ×œ×¤× ×™ ×©×‘×•×¢? ××ª××•×œ?")
        if "××™×¤×”" in missing:
            q.append("××™×¤×” ×”×™×™×ª×? ×‘×‘×™×ª? ×‘×¢×‘×•×“×”? ×‘×©×™×—×”?")
        if "××™" in missing:
            q.append("×¢× ××™ ×”×™×”? ××™ ×¢×•×“ ×”×™×” ×©×?")
        if "××”" in missing:
            q.append("××” ×‘×“×™×•×§ ×§×¨×”? ××” × ×××¨? ××™×š ×”×’×™×‘×•?")
        if not q:
            q = ["××” ×‘×“×™×•×§ ×§×¨×” ×©×?"]
        prefix = "×× ×™ ××‘×™×Ÿ ×©××ª×” ×¨×•×¦×” ×œ×”××©×™×š. ×›×“×™ ×©× ×•×›×œ ×œ×–×”×•×ª ××ª ×”×“×¤×•×¡, ×× ×™ ×¦×¨×™×š ×¨×’×¢ ××—×“ ×¡×¤×¦×™×¤×™. "
        return prefix + " ".join(q)
    else:
        q = []
        if "××ª×™" in missing:
            q.append("When did it happen? Last week? Recently?")
        if "××™×¤×”" in missing:
            q.append("Where were you? At home? At work?")
        if "××™" in missing:
            q.append("Who was there? Who else was involved?")
        if "××”" in missing:
            q.append("What exactly happened? What was said? How did they react?")
        if not q:
            q = ["What exactly happened there?"]
        prefix = "I understand you want to continue. To identify your pattern, I need one specific moment. "
        return prefix + " ".join(q)


def validate_stage_transition(
    old_step: str,
    new_step: str,
    state: Dict[str, Any],
    language: str,
    coach_message: str = ""
) -> Tuple[bool, Optional[str]]:
    """
    Safety net: validate if stage transition is premature.
    
    Args:
        old_step: Current step before transition
        new_step: Proposed new step
        state: Current conversation state
        language: "he" or "en"
        coach_message: The LLM's proposed message (to check if already in new stage)
    
    Returns:
        (is_valid, correction_message)
        - If is_valid=True, allow the transition
        - If is_valid=False, return correction message to override LLM response
    """
    # Compute stage indexes once (guards against unbound locals)
    stage_order = ["S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13"]
    old_idx = stage_order.index(old_step) if old_step in stage_order else -1
    new_idx = stage_order.index(new_step) if new_step in stage_order else -1

    # GENERIC SOLUTION: Check if user wants to move on
    recent_user_messages = [
        msg.get("content", "").lower() for msg in state.get("messages", [])[-3:]
        if msg.get("sender") == "user"
    ]
    
    if language == "he":
        move_on_keywords = [
            "××¡×›×", "×–×” ×”×›×œ", "×–×”×•", "× ×ª×§×“×", "×”×œ××”", "×“×™", "×“×™ ×œ×™",
            "×›×œ ×”×¨×’×©×•×ª", "×›×‘×¨ ×›×ª×‘×ª×™", "×‘×•× × ×ª×§×“×", "××” ×”×œ××”",
            "×××¨×ª×™ ×›×‘×¨", "×›×‘×¨ ×××¨×ª×™", "×¢× ×™×ª×™", "×–×” ××¡×¤×™×§", "×œ×"
        ]
    else:
        move_on_keywords = [
            "that's all", "let's move", "move on", "enough", "that's it",
            "i already said", "already told", "move forward", "what's next"
        ]
    
    user_wants_to_move_on = any(
        keyword in msg for msg in recent_user_messages
        for keyword in move_on_keywords
    )
    
    # If user explicitly wants to move on, ALWAYS allow transition
    if user_wants_to_move_on:
        logger.info(f"[Safety Net] User wants to move on - allowing {old_step}â†’{new_step}")
        return True, None
    
    # Otherwise, check minimum turns for critical transitions
    
    # ğŸš¨ CRITICAL: S1â†’S2 - Must have clear topic!
    if old_step == "S1" and new_step == "S2":
        has_topic, reason = has_clear_topic_for_s2(state)
        
        if not has_topic:
            logger.warning(f"[Safety Net] Blocking S1â†’S2: topic not clear ({reason})")
            if language == "he":
                return False, "×× ×™ ××‘×™×Ÿ ×©××ª×” ×¨×•×¦×” ×œ×”××©×™×š. ××‘×œ **×œ×¤× ×™ ×©× ×™×§×— ××™×¨×•×¢ ×¡×¤×¦×™×¤×™, ×× ×™ ×¦×¨×™×š ×œ×”×‘×™×Ÿ ×‘×“×™×•×§ ×¢×œ ××” ××ª×” ×¨×•×¦×” ×œ×”×ª×××Ÿ**. ×¡×¤×¨ ×œ×™ - ××” ××¢×¡×™×§ ××•×ª×š?"
            else:
                return False, "I understand you want to continue. But **before we take a specific event, I need to understand exactly what you want to work on**. Tell me - what's on your mind?"
    
    # ğŸš¨ CRITICAL: Block S1â†’S3 (can't skip S2 event!)
    if old_step == "S1" and new_step == "S3":
        # âœ… EXCEPTION: If user already gave event details, allow S3 (state may be stale)
        has_event, _ = has_sufficient_event_details(state)
        if has_event:
            logger.info(f"[Safety Net] User already gave event in S1 context â†’ allowing S1â†’S3")
            return True, None
        logger.error(f"[Safety Net] ğŸš« BLOCKED S1â†’S3: Cannot skip S2 (event)!")
        topic = (state.get("collected_data") or {}).get("topic") or ""
        # Sanitize: LLM might copy placeholder "[× ×•×©×]" from prompt
        if topic and ("[" in topic or "]" in topic or topic.strip() in ("[× ×•×©×]", "[topic]")):
            topic = ""
        if not topic:
            # Fallback: use first substantial user message as topic hint (e.g. "×œ×•××¨ ×œ×", "× ××× ×•×ª ×œ×¢×¦××™")
            for msg in (state.get("messages") or []):
                if msg.get("sender") == "user":
                    content = (msg.get("content") or "").strip()
                    if len(content) >= 5 and len(content) <= 80:
                        topic = content
                        break
        if language == "he":
            if topic:
                msg = f"×‘×•× × ×™×§×— **××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“** ×©×§×¨×” ×œ××—×¨×•× ×”. ×¡×¤×¨ ×œ×™ ×¢×œ ×¤×¢× ××—×ª ×©{topic} - ××ª×™ ×–×” ×”×™×”? ×¢× ××™?"
            else:
                msg = "×‘×•× × ×™×§×— **××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“** ×©×§×¨×” ×œ××—×¨×•× ×”. ×¡×¤×¨ ×œ×™ ×¢×œ ×¤×¢× ××—×ª - ××ª×™ ×–×” ×”×™×”? ×¢× ××™?"
            return False, msg
        else:
            if topic:
                msg = f"Let's take **one specific event** that happened recently. Tell me about one time when {topic} - when was it? Who was there?"
            else:
                msg = "Let's take **one specific event** that happened recently. Tell me about one time - when was it? Who was there?"
            return False, msg
    
    # ğŸš¨ CRITICAL: Block S1â†’S4, S1â†’S5, etc. (can't skip multiple stages!)
    if old_step == "S1" and new_idx > 2:
        # âœ… EXCEPTION: If user already gave event details (e.g. re_ask_check moved us), allow
        has_event, _ = has_sufficient_event_details(state)
        if has_event:
            logger.info(f"[Safety Net] User already gave event â†’ allowing S1â†’{new_step}")
            return True, None
        logger.error(f"[Safety Net] ğŸš« BLOCKED S1â†’{new_step}: Cannot skip S2!")
        if language == "he":
            return False, "×¨×’×¢, ×‘×•× ×§×•×“× × ×™×§×— ××™×¨×•×¢ ×¡×¤×¦×™×¤×™ ××—×“. ×¡×¤×¨ ×œ×™ ×¢×œ ×¤×¢× ××—×ª ×œ××—×¨×•× ×” - ××ª×™ ×–×” ×”×™×”?"
        else:
            return False, "Wait, let's first take one specific event. Tell me about one time recently - when was it?"
    
    # ğŸš¨ CRITICAL: Block S2â†’S4 (can't skip S3 emotions!)
    if old_step == "S2" and new_step == "S4":
        logger.error(f"[Safety Net] ğŸš« BLOCKED S2â†’S4: Cannot skip S3 (emotions)!")
        if language == "he":
            return False, "×¨×’×¢, ×œ×¤× ×™ ×©× ×“×‘×¨ ×¢×œ ××—×©×‘×•×ª - ×¡×¤×¨ ×œ×™ ×§×•×“× **××” ×”×¨×’×©×ª** ×‘××•×ª×• ×¨×’×¢?"
        else:
            return False, "Wait, before we talk about thoughts - tell me first **what did you feel** in that moment?"
    
    # ğŸš¨ CRITICAL: Block backwards transitions (can't go backwards!)
    # Don't allow going backwards (except to S0/S1 which are resets)
    if old_idx >= 2 and new_idx >= 2 and new_idx < old_idx:
        logger.error(f"[Safety Net] ğŸš« BLOCKED backwards transition {old_step}â†’{new_step}")
        if language == "he":
            return False, "×‘×•× × ××©×™×š ×”×œ××” ×‘××§×•× ×œ×—×–×•×¨ ××—×•×¨×”."
        else:
            return False, "Let's move forward instead of going backwards."
    
    # S2â†’S3: Need detailed event (at least 3 turns in S2)
    if old_step == "S2" and new_step == "S3":
        s2_turns = count_turns_in_step(state, "S2")
        
        # ğŸš¨ CRITICAL: Check if stuck in loop
        if detect_stuck_loop(state):
            logger.error(f"[Safety Net] ğŸ”„ LOOP DETECTED! Forcing progression to S3")
            return True, None  # Force progression!
        
        # ğŸš¨ CRITICAL: Check if user already gave emotions (wrong stage!)
        if user_already_gave_emotions(state):
            logger.info(f"[Safety Net] âœ… User already gave emotions, allowing S2â†’S3 transition")
            return True, None  # Allow transition
        
        # ğŸš¨ NEW LOGIC: Check if user is frustrated
        user_msg = state.get("messages", [])[-1].get("content", "") if state.get("messages") else ""
        if user_wants_to_continue(user_msg):
            logger.warning(f"[Safety Net] ğŸ¤” User frustrated - checking if we have sufficient info...")
            
            # Check if we actually have enough event details
            has_info, reason = has_sufficient_event_details(state)
            
            if has_info:
                # Good to go - user is frustrated but we have enough info
                logger.info(f"[Safety Net] âœ… User frustrated BUT has sufficient details â†’ allowing S2â†’S3")
                return True, None
            else:
                # Need more info - EXPLAIN why instead of just asking again
                logger.warning(f"[Safety Net] âš ï¸ User frustrated BUT missing details ({reason}) â†’ explaining")
                explanation = get_explanatory_response_for_missing_details(reason, language)
                return False, explanation
        
        # ğŸ¯ Check if LLM already asked an S3 question (emotions)
        # If yes, allow the transition even if s2_turns < 3
        # This prevents overriding good LLM responses
        if language == "he":
            s3_indicators = ["××” ×”×¨×’×©×ª", "××™×–×” ×¨×’×©", "××” ×¢×‘×¨ ×‘×š", "××” × ×’×¢ ×‘×š", "×”×ª×¢××§ ×‘×¨×’×©×•×ª"]
        else:
            s3_indicators = ["what did you feel", "what emotion", "how did you feel", "feelings", "emotions"]
        
        llm_already_in_s3 = any(indicator in coach_message.lower() for indicator in s3_indicators)
        
        if llm_already_in_s3:
            logger.info(f"[Safety Net] LLM already asked S3 question, allowing transition despite {s2_turns} turns")
            return True, None  # Allow transition
        
        # If LLM hasn't moved to S3 yet: use BSD-aligned targeted questions (××ª×™, ××™×¤×”, ××™, ××”)
        if s2_turns < 3:
            has_info, reason = has_sufficient_event_details(state)
            if has_info:
                return True, None  # We have enough per BSD criteria
            logger.warning(f"[Safety Net] Blocked S2â†’S3: missing ({reason})")
            question = get_explanatory_response_for_missing_details(reason, language)
            return False, question
    
    # S3â†’S4: Need emotions (at least 3 turns in S3)
    if old_step == "S3" and new_step == "S4":
        s3_turns = count_turns_in_step(state, "S3")
        
        # ğŸš¨ CRITICAL: Check if stuck in loop
        if detect_stuck_loop(state):
            logger.error(f"[Safety Net] ğŸ”„ LOOP DETECTED! Forcing progression to S4")
            return True, None  # Force progression!
        
        # ğŸš¨ NEW LOGIC: Check if user is frustrated
        user_msg = state.get("messages", [])[-1].get("content", "") if state.get("messages") else ""
        if user_wants_to_continue(user_msg):
            logger.warning(f"[Safety Net] ğŸ¤” User frustrated in S3 - checking if we have sufficient emotions...")
            
            # For S3, if user already gave emotions, that's usually enough
            # Check if we have at least some emotion words
            if user_already_gave_emotions(state):
                logger.info(f"[Safety Net] âœ… User frustrated BUT has emotions â†’ allowing S3â†’S4")
                return True, None
            else:
                # Missing emotions - explain why we need them
                logger.warning(f"[Safety Net] âš ï¸ User frustrated BUT no emotions yet â†’ explaining")
                if language == "he":
                    explanation = (
                        "×× ×™ ××‘×™×Ÿ ×©××ª×” ×¨×•×¦×” ×œ×”××©×™×š. "
                        "×”×¡×™×‘×” ×©×× ×™ ×¦×¨×™×š ×œ×©××•×¢ ×¢×œ ×”×¨×’×©×•×ª ×©×œ×š ×”×™× ×©×”×Ÿ ×—×œ×§ ××¨×›×–×™ ×‘×“×¤×•×¡ - "
                        "×”×“×¤×•×¡ ×”×•× ×”×©×™×œ×•×‘ ×©×œ ×”××¦×‘, ×”×¨×’×© ×•×”××—×©×‘×” ×©×—×•×–×¨×™×. "
                        "××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?"
                    )
                else:
                    explanation = (
                        "I understand you want to continue. "
                        "The reason I need to hear about your emotions is that they're a central part of the pattern - "
                        "the pattern is the combination of situation, emotion, and thought that repeats. "
                        "What did you feel in that moment?"
                    )
                return False, explanation
        
        # ğŸ¯ Check if LLM already asked an S4 question (thoughts)
        # If yes, allow the transition even if s3_turns < 3
        if language == "he":
            s4_indicators = ["××” ×¢×‘×¨ ×œ×š ×‘×¨××©", "××” ×—×©×‘×ª", "××” ×××¨×ª ×œ×¢×¦××š", "××™×–×” ××©×¤×˜", "××—×©×‘"]
        else:
            s4_indicators = ["what went through your mind", "what did you think", "what did you tell yourself", "thought"]
        
        llm_already_in_s4 = any(indicator in coach_message.lower() for indicator in s4_indicators)
        
        if llm_already_in_s4:
            logger.info(f"[Safety Net] LLM already asked S4 question, allowing transition despite {s3_turns} turns")
            return True, None  # Allow transition
        
        # If user already gave emotions (2+), allow S3â†’S4 - no need to drill each one
        if user_already_gave_emotions(state):
            logger.info(f"[Safety Net] User gave emotions â†’ allowing S3â†’S4 (no per-emotion drilling)")
            return True, None
        
        # If LLM hasn't moved to S4 yet, check turns count
        if s3_turns < 3:
            logger.warning(f"[Safety Net] Blocked S3â†’S4: only {s3_turns} turns in S3")
            if language == "he":
                return False, "××” ×¢×•×“ ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?"
            else:
                return False, "What else did you feel in that moment?"
    
    # S8â†’S9: Need pattern confirmation
    if old_step == "S8" and new_step == "S9":
        # Check if user explicitly said they don't understand the pattern
        if language == "he":
            confusion_keywords = ["×œ× ×™×•×“×¢ ××” ×”×“×¤×•×¡", "×œ× ××‘×™×Ÿ ××” ×”×“×¤×•×¡", "××” ×”×“×¤×•×¡", "××™×–×” ×“×¤×•×¡"]
        else:
            confusion_keywords = ["don't know the pattern", "what pattern", "which pattern", "what is the pattern"]
        
        user_confused = any(
            keyword in msg for msg in recent_user_messages
            for keyword in confusion_keywords
        )
        
        if user_confused:
            logger.warning(f"[Safety Net] Blocked S8â†’S9: user doesn't understand the pattern yet")
            if language == "he":
                # Need to explicitly summarize the pattern
                return False, "×× ×™ ××‘×™×Ÿ. ×‘×•× × ×¡×›×: ×”×“×¤×•×¡ ×”×•× ×©××ª×” ××’×™×‘ ×‘×“×¨×š ××¡×•×™××ª ×‘××¦×‘×™× ×©×•× ×™×. ××” ×”×ª×’×•×‘×” ×©×œ×š ×©×—×•×–×¨×ª? ××” ××©×•×ª×£ ×‘×™×Ÿ ×”××¦×‘×™× ×©×ª×™××¨×ª?"
            else:
                return False, "I understand. Let's summarize: the pattern is that you respond in a certain way in different situations. What's your response that repeats? What's common between the situations you described?"
        
        # ğŸš¨ NEW: Check if user already gave examples and said so
        user_msg = state.get("messages", [])[-1].get("content", "") if state.get("messages") else ""
        example_count = count_pattern_examples_in_s7(state)
        
        if example_count >= 2 and user_said_already_gave_examples(user_msg):
            logger.info(f"[Safety Net] User gave {example_count} examples + said 'already told' â†’ allowing S8â†’S9")
            return True, None
        
        # ğŸš¨ NEW: Check if stuck in loop asking "where else?"
        if detect_stuck_loop(state) and example_count >= 2:
            logger.error(f"[Safety Net] LOOP in S8 with {example_count} examples â†’ forcing S9")
            return True, None
        
        # Check if we have sufficient examples (content-based, not just turns)
        s8_turns = count_turns_in_step(state, "S8")
        
        if example_count >= 2 and s8_turns >= 3:
            # Has enough examples and turns â†’ allow transition
            logger.info(f"[Safety Net] S8 has {example_count} examples + {s8_turns} turns â†’ allowing S8â†’S9")
            return True, None
        
        if s8_turns < 3:
            logger.warning(f"[Safety Net] Blocked S8â†’S9: only {s8_turns} turns and {example_count} examples")
            if language == "he":
                # GENERIC: Varied questions to explore pattern depth
                pattern_questions = [
                    "××™×¤×” ×¢×•×“ ××ª×” ××–×”×” ××ª ×”×ª×’×•×‘×” ×”×–×• ×©×œ×š?",
                    "×”×× ×–×” ×§×•×¨×” ×¨×§ ×‘××¦×‘×™× ××¡×•×™××™×, ××• ×’× ×‘××§×•××•×ª ××—×¨×™×?",
                    "××” ××©×•×ª×£ ×œ×›×œ ×”××¦×‘×™× ×©×ª×™××¨×ª? ××” **××ª×”** ×¢×•×©×” ×©×—×•×–×¨?"
                ]
                question = pattern_questions[min(s8_turns, len(pattern_questions) - 1)]
                return False, question
            else:
                pattern_questions = [
                    "Where else do you recognize this response of yours?",
                    "Does this happen only in certain situations, or in other places too?",
                    "What's common to all the situations you described? What do **you** do that repeats?"
                ]
                question = pattern_questions[min(s8_turns, len(pattern_questions) - 1)]
                return False, question
    
    # All other transitions: trust the LLM
    return True, None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTEXT BUILDER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def build_conversation_context(
    state: Dict[str, Any],
    user_message: str,
    language: str
) -> str:
    """
    Build rich context for LLM.
    
    Includes:
    - Current state (step, collected data)
    - Recent conversation history
    - User's new message
    
    Args:
        state: Current conversation state
        user_message: User's new message
        language: "he" or "en"
    
    Returns:
        Context string for LLM
    """
    # Context window tuning (preserve methodology, reduce repetitive token load)
    # Default keeps enough turns for BSD stage continuity while avoiding long-tail drift.
    history_last_n = int(os.getenv("BSD_V2_HISTORY_LAST_N", "8"))
    max_msg_chars = int(os.getenv("BSD_V2_HISTORY_MSG_MAX_CHARS", "420"))

    # Some stages benefit from slightly wider local context.
    if state.get("current_step") in {"S2", "S3", "S8"}:
        history_last_n = max(history_last_n, 10)

    # Get recent history
    history = get_conversation_history(state, last_n=history_last_n)
    logger.info(
        f"[BSD V2 CONTEXT] History window={history_last_n}, max_msg_chars={max_msg_chars}, loaded={len(history)}"
    )
    
    # Build context
    context_parts = []
    
    # Current state
    context_parts.append("# ××¦×‘ × ×•×›×—×™" if language == "he" else "# Current State")
    context_parts.append(f"×©×œ×‘: {state['current_step']}" if language == "he" else f"Stage: {state['current_step']}")
    context_parts.append(f"Saturation Score: {state['saturation_score']:.1f}")
    
    # Collected data (non-null only)
    collected = {k: v for k, v in state['collected_data'].items() if v is not None and v != [] and v != {}}
    if collected:
        context_parts.append("\n× ×ª×•× ×™× ×©× ××¡×¤×•:" if language == "he" else "\nCollected Data:")
        context_parts.append(json.dumps(collected, ensure_ascii=False, indent=2))
        if state.get("current_step") in ("S5", "S6", "S7"):
            context_parts.append("\nğŸš¨ ×”×©×ª××© ×‘× ×ª×•× ×™× ×”××œ×” ×œ×‘× ×™×™×ª ×”×¡×™×›×•×! ××œ ×ª×¡×›× ×‘×œ×™ ×œ×“×¢×ª ××” × ××¡×£." if language == "he" else "\nğŸš¨ Use this data to build the summary! Don't summarize without knowing what was collected.")
    
    # Extract event details from history for S2 (to prevent repeated questions)
    if state['current_step'] == 'S2' and history:
        event_summary = []
        for msg in history:
            if msg['sender'] == 'user':
                content = msg['content'].lower()
                # Check for location mentions
                if '×‘×—×“×¨' in content or '×‘×‘×™×ª' in content or '×‘××§×•×' in content:
                    event_summary.append(f"âœ“ ××§×•× ×›×‘×¨ × ×××¨: {msg['content'][:80]}...")
                # Check for time mentions
                if '××ª××•×œ' in content or '×©×™×©×™' in content or '×©×‘×•×¢' in content or '×—×•×“×©' in content:
                    event_summary.append(f"âœ“ ×–××Ÿ ×›×‘×¨ × ×××¨: {msg['content'][:80]}...")
                # Check for people mentions
                if '××©×ª×™' in content or '×‘×ª ×–×•×’' in content or '×™×œ×“×™×' in content:
                    event_summary.append(f"âœ“ ××™ ×›×‘×¨ × ×××¨: {msg['content'][:80]}...")
        
        if event_summary:
            context_parts.append("\nğŸš¨ ×—×©×•×‘ - ×¤×¨×˜×™× ×©×›×‘×¨ × ×××¨×• ×¢×œ ×”××™×¨×•×¢:" if language == "he" else "\nğŸš¨ Important - Event details already mentioned:")
            context_parts.extend(event_summary)
            if language == "he":
                context_parts.append("âš ï¸ ××œ ×ª×©××œ ×©×•×‘ ×¢×œ ×¤×¨×˜×™× ×©×›×‘×¨ × ×××¨×•!")
            else:
                context_parts.append("âš ï¸ Don't ask again about details already mentioned!")
    
    # Conversation history with EMPHASIS
    if history:
        context_parts.append("\n# ×”×™×¡×˜×•×¨×™×” ××—×¨×•× ×” - ×§×¨× ×‘×¢×™×•×Ÿ!" if language == "he" else "\n# Recent History - Read Carefully!")
        if language == "he":
            context_parts.append("ğŸš¨ ×—×©×•×‘: ××œ ×ª×©××œ ×©××œ×•×ª ×©×”××©×ª××© ×›×‘×¨ ×¢× ×” ×¢×œ×™×”×Ÿ ×‘×”×™×¡×˜×•×¨×™×”!")
        else:
            context_parts.append("ğŸš¨ Important: Don't ask questions the user already answered in the history!")
        
        for msg in history:
            sender_value = msg.get("sender", "unknown")
            content_value = msg.get("content", "")
            if not content_value:  # Skip empty messages
                continue
            # Keep only the informative head of long turns to reduce repeated token cost.
            if len(content_value) > max_msg_chars:
                content_value = content_value[:max_msg_chars] + " ...[truncated]"
            sender = "××©×ª××©" if sender_value == "user" else "××××Ÿ"
            if language == "en":
                sender = "User" if sender_value == "user" else "Coach"
            context_parts.append(f"{sender}: {content_value}")
    
    # New message
    context_parts.append("\n# ×”×•×“×¢×” ×—×“×©×”" if language == "he" else "\n# New Message")
    context_parts.append(f"××©×ª××©: {user_message}" if language == "he" else f"User: {user_message}")
    
    context = "\n".join(context_parts)
    logger.info(
        f"[PERF] Context size chars={len(context)}, history_msgs={len(history)}, step={state.get('current_step')}"
    )
    return context


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN HANDLER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def handle_conversation(
    user_message: str,
    state: Dict[str, Any],
    language: str = "he"
) -> Tuple[str, Dict[str, Any]]:
    """
    Handle single conversation turn in V2.
    
    Flow:
    1. Build context from state + history + new message
    2. Call LLM with system prompt
    3. Parse JSON response
    4. Extract coach message and internal state
    5. Update state
    6. Return (coach_message, updated_state)
    
    Args:
        user_message: User's message
        state: Current conversation state
        language: "he" or "en"
    
    Returns:
        (coach_message, updated_state)
    """
    # Per-turn debug: repetition & stage transition tracking
    overrides_applied: List[str] = []
    _bsd_log("TURN_START", step=state['current_step'], saturation=state['saturation_score'],
             msg_count=len(state.get('messages', [])), user_preview=user_message[:80])
    logger.info(f"[BSD V2] Handling message: '{user_message[:50]}...'")
    logger.info(f"[BSD V2] Current step: {state['current_step']}, saturation: {state['saturation_score']:.2f}")
    logger.info(f"[BSD V2] Message count in state: {len(state.get('messages', []))}")
    
    # ğŸš¨ CRITICAL: Check if user is asking about unrelated event
    if state["current_step"] == "S2" and user_questions_unrelated_event(user_message):
        logger.info(f"[Safety Net] User asking about unrelated event - explaining directly")
        if language == "he":
            explanation = """×©××œ×” ××¢×•×œ×”! ×”×¡×™×˜×•××¦×™×” **×œ× ×—×™×™×‘×ª** ×œ×”×™×•×ª ×§×©×•×¨×” ×œ× ×•×©× ×”××™××•×Ÿ.

×œ××”? ×›×™ **×”×“×¤×•×¡ ×©×œ×š ×”×•×œ×š ××™×ª×š ×œ×›×œ ××§×•×** - ×œ×‘×™×ª, ×œ×¢×‘×•×“×”, ×œ×—×‘×¨×™×, ×œ×›×œ ×ª×—×•× ×‘×—×™×™×.

×œ×¤×¢××™× ×“×•×•×§× ×‘××™×¨×•×¢ ××ª×—×•× **××—×¨ ×œ×’××¨×™** (×œ××©×œ: ×©×™×—×” ×¢× ×—×‘×¨, ××¦×‘ ×‘×¢×‘×•×“×”, ××™× ×˜×¨××§×¦×™×” ×¢× ×‘×Ÿ ××©×¤×—×”) ×”×“×¤×•×¡ ××ª×’×œ×” ×‘×¦×•×¨×” ×”×›×™ **× ×§×™×™×” ×•×‘×¨×•×¨×”** - ×‘×œ×™ ×”×¨×‘×” "×¨×¢×©" ×¡×‘×™×‘.

××– ×ª×¨×’×™×© ×—×•×¤×©×™ ×œ×©×ª×£ ××™×¨×•×¢ ××›×œ ×ª×—×•× ×©×‘×• ×”×™×™×ª ×‘××™× ×˜×¨××§×¦×™×” ×¢× ×× ×©×™× ×•×”×¨×’×©×ª ×¡×¢×¨×” ×¨×’×©×™×ª. ××” ×¢×•×œ×” ×œ×š?"""
        else:
            explanation = """Great question! The situation **doesn't have to** be related to the coaching topic.

Why? Because **your pattern goes with you everywhere** - home, work, friends, every area of life.

Sometimes a situation from a **completely different area** (e.g., conversation with a friend, situation at work, interaction with family) reveals the pattern most **clearly** - without a lot of "noise" around it.

So feel free to share an event from any area where you interacted with people and felt emotional turmoil. What comes to mind?"""
        
        # Add this as a coach response directly, no need for LLM
        internal_state = {
            "current_step": state["current_step"],  # Stay in same stage
            "saturation_score": state.get("saturation_score", 0.3),
            "reflection": "Explained why event doesn't need to be related to topic"
        }
        state = add_message(state, "user", user_message)
        state = add_message(state, "coach", explanation, internal_state)
        return explanation, state
    
    # Check if user is frustrated - Use EXPLICIT phrases only (no single words)
    # This avoids false positives like "×œ× ×—×© ××¡×¤×™×§ ×˜×•×‘" while catching real frustration
    
    user_frustrated = False
    if language == "he":
        user_msg_lower = user_message.lower()
        
        # ONLY very explicit frustration phrases (2+ words)
        # Do NOT use single words like "×“×™", "××¡×¤×™×§", "×–×”×•" alone
        explicit_frustration_phrases = [
            "×××¨×ª×™ ×›×‘×¨", "×××¨×ª×™ ×œ×š", "×›×‘×¨ ×××¨×ª×™", "×›×‘×¨ ×¡×™×¤×¨×ª×™",
            "×¡×¤×¨×ª×™ ×œ×š", "×¡×¤×¨×ª×™ ×œ×š ×¢×œ", "×¢×©×™× ×• ×–××ª ×›×‘×¨", "×‘×•× × ×ª×§×“×",
            "×–×” ×—×•×–×¨ ×©×•×‘", "×–×” ×—×•×–×¨", "×›×‘×¨ ×¡×¤×¨×ª×™ ×¢×œ",
            "×—×–×¨×ª ×¢×œ ×¢×¦××š", "××ª×” ×—×•×–×¨", "×¢× ×™×ª×™ ×›×‘×¨", "×¢× ×™×ª×™ ×œ×š",
            "×¢× ×™×ª×™ ×”×›×™ ×˜×•×‘", "×¢× ×™×ª×™ ×”×›×™ ×˜×•×‘ ×©×”×¦×œ×—×ª×™", "×–×” ×”×›×™ ×˜×•×‘ ×©×™×›×•×œ×ª×™",
            "×“×™ ×›×‘×¨", "×“×™ ×“×™", "××¡×¤×™×§ ×›×‘×¨", "×“×™ ×œ×™ ×›×‘×¨",
            "××” ×”×›×•× ×”", "××” ×”×›×•×•× ×”", "×œ× ×”×‘× ×ª×™", "××” ×›×•×•× ×ª×š"
        ]
        
        user_frustrated = any(phrase in user_msg_lower for phrase in explicit_frustration_phrases)
    else:
        explicit_frustration_phrases = [
            "i already said", "i told you", "already told you", "i told you about",
            "you're repeating", "i already answered", "stop repeating",
            "this is repeating", "it keeps repeating",
            "i answered the best i could", "that's the best i could do",
            "what do you mean", "i don't understand", "i didn't understand"
        ]
        user_frustrated = any(phrase in user_message.lower() for phrase in explicit_frustration_phrases)
    
    if user_frustrated:
        _bsd_log("USER_FRUSTRATED", step=state['current_step'], user_msg=user_message[:60])
        logger.warning(f"[Safety Net] User is frustrated ('{user_message}') - checking if can progress")
        current_step = state['current_step']
        
        # Add user message first
        state = add_message(state, "user", user_message)
        
        # ğŸ¯ SPECIAL HANDLING FOR S1 - check if topic/event before progressing
        if current_step == "S1":
            has_event, _ = has_sufficient_event_details(state)
            has_topic, reason = has_clear_topic_for_s2(state)
            
            if has_event:
                # âœ… User already gave event - move to S3 (emotions)!
                logger.info(f"[Safety Net] User frustrated in S1, but already gave event â†’ moving to S3")
                if language == "he":
                    apology_message = "××¦×˜×¢×¨ ×¢×œ ×”×—×–×¨×”! ×©××¢×ª×™ ×¢×œ ×”××™×¨×•×¢. ×¢×›×©×™×• â€“ ××” ×”×¨×’×©×ª ×‘××•×ª×• ×¨×’×¢?"
                else:
                    apology_message = "Sorry for repeating! I heard about the event. Now â€“ what did you feel in that moment?"
                next_step = "S3"
            elif has_topic:
                # âœ… Topic is clear - can progress to S2
                logger.info(f"[Safety Net] User frustrated/confused in S1, but topic is clear â†’ moving to S2")
                confusion_phrases = ["××” ×”×›×•× ×”", "××” ×”×›×•×•× ×”", "×œ× ×”×‘× ×ª×™", "××” ×›×•×•× ×ª×š", "what do you mean", "i don't understand"]
                is_confusion = any(p in user_message.lower() for p in confusion_phrases)
                if language == "he":
                    prefix = "×¡×œ×™×—×” ×¢×œ ×”×©××œ×” ×”××¡×•×‘×›×ª. " if is_confusion else "×× ×™ ××‘×™×Ÿ. "
                else:
                    prefix = "Sorry for the confusing question. " if is_confusion else "I understand. "
                apology_message = f"{prefix}{get_next_step_question(current_step, language)}"
                next_step = "S2"
            else:
                # âš ï¸ Topic not clear - EXPLAIN why we need more info
                logger.warning(f"[Safety Net] User frustrated in S1, but topic not clear ({reason}) â†’ explaining")
                apology_message = get_s1_explanation_for_missing_info(reason, language)
                next_step = "S1"  # Stay in S1 but with explanation
        else:
            # For other stages, use standard progression
            if language == "he":
                apology_message = f"××¦×˜×¢×¨ ×¢×œ ×”×—×–×¨×”! {get_next_step_question(current_step, language)}"
            else:
                apology_message = f"Sorry for repeating! {get_next_step_question(current_step, language)}"
            
            # Determine next step
            step_progression = {
                "S0": "S1", "S1": "S2", "S2": "S3", "S3": "S4",
                "S4": "S5", "S5": "S6", "S6": "S7", "S7": "S8",
                "S8": "S9", "S9": "S10", "S10": "S11", "S11": "S12", "S12": "S13"
            }
            next_step = step_progression.get(current_step, current_step)
        
        # Add coach response
        internal_state = {
            "current_step": next_step,
            "saturation_score": 0.3,
            "reflection": f"User frustrated - moving from {current_step} to {next_step}"
        }
        state = add_message(state, "coach", apology_message, internal_state)
        
        return apology_message, state
    
    try:
        start_time = time.time()
        
        # 1. Build context
        t1 = time.time()
        context = build_conversation_context(state, user_message, language)
        t2 = time.time()
        logger.info(f"[PERF] Build context: {(t2-t1)*1000:.0f}ms ({len(context)} chars)")
        
        # 2. Prepare messages using modular stage-aware prompt assembly.
        current_step = state.get("current_step", "S1")
        system_prompt = _get_system_prompt(state=state, user_message=user_message, language=language)
        logger.info(
            "[PERF] System prompt chars from prompt_manager: %s",
            len(system_prompt),
        )
        
        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=context)
        ]
        
        # 3. Call LLM
        t3 = time.time()
        llm = get_azure_chat_llm(purpose="talker")  # Higher temperature for natural conversation
        # Azure prompt caching is enabled by default for supported models.
        # prompt_cache_key improves cache hit routing for repeated BSD system-prefix.
        cache_key_prefix = os.getenv("AZURE_OPENAI_PROMPT_CACHE_KEY_PREFIX", "bsd_v2_markdown_prompt")
        cache_key = f"{cache_key_prefix}:main_coach:{language}:{current_step}"
        response = await _ainvoke_with_prompt_cache(llm, messages, cache_key=cache_key)
        t4 = time.time()
        
        response_text = response.content.strip()
        
        logger.info(f"[PERF] LLM call: {(t4-t3)*1000:.0f}ms")
        logger.info(f"[BSD V2] LLM response ({len(response_text)} chars)")
        logger.info(f"[BSD V2] LLM response preview: {response_text[:500]}...")
        token_usage = getattr(response, "response_metadata", {}).get("token_usage", {})
        prompt_token_details = token_usage.get("prompt_tokens_details", {})
        cached_tokens = prompt_token_details.get("cached_tokens")
        if cached_tokens is not None:
            logger.info(f"[PERF] Prompt cache hit tokens: {cached_tokens}")
        
        # 4. Parse JSON response
        t5 = time.time()
        try:
            # Clean markdown code blocks if present
            if response_text.startswith("```"):
                response_text = response_text.split("```")[1]
                if response_text.startswith("json"):
                    response_text = response_text[4:]
                response_text = response_text.strip()

            parsed = None
            trailing_text = ""

            # 1) Preferred path: full JSON payload
            try:
                parsed = json.loads(response_text)
            except json.JSONDecodeError:
                # 2) Fallback: JSON prefix + trailing natural-language line
                decoder = json.JSONDecoder()
                for start_idx, ch in enumerate(response_text):
                    if ch != "{":
                        continue
                    try:
                        candidate, end_idx = decoder.raw_decode(response_text[start_idx:])
                        if isinstance(candidate, dict):
                            parsed = candidate
                            trailing_text = response_text[start_idx + end_idx :].strip().strip('"')
                            break
                    except json.JSONDecodeError:
                        continue

            if parsed is None:
                raise json.JSONDecodeError("Could not parse model JSON payload", response_text, 0)

            # Try both field names for backwards compatibility
            coach_message = (
                parsed.get("coach_message", "")
                or parsed.get("response", "")
                or parsed.get("question", "")
                or trailing_text
            )
            internal_state = parsed.get("internal_state", {})

            # Log LLM decision for debugging transitions
            llm_step = internal_state.get("current_step", parsed.get("stage"))
            llm_sat = internal_state.get("saturation_score")
            cd = internal_state.get("collected_data") or {}
            cd_keys = [k for k, v in cd.items() if v is not None and v != [] and v != {}]
            _bsd_log("LLM_DECISION", step=llm_step, saturation=llm_sat,
                     collected_data_keys=cd_keys, coach_preview=(coach_message or "")[:60])

            # Backward compatibility for metadata-style payloads returned by the model
            if not internal_state:
                stage = parsed.get("stage", state["current_step"])
                saturation = parsed.get(
                    "saturation_score",
                    parsed.get("Saturation Score", state["saturation_score"])
                )
                internal_state = {
                    "current_step": stage if isinstance(stage, str) else state["current_step"],
                    "saturation_score": float(saturation) if isinstance(saturation, (int, float)) else state["saturation_score"],
                    "reflection": "Parsed legacy metadata payload",
                }

            # Never expose raw metadata JSON to end users
            if isinstance(coach_message, str) and coach_message.strip().startswith("{"):
                coach_message = trailing_text or ""

            if not coach_message:
                coach_message = get_next_step_question(state.get("current_step", "S1"), language)

        except json.JSONDecodeError as e:
            logger.error(f"[BSD V2] Failed to parse JSON: {e}")
            logger.error(f"[BSD V2] Response text: {response_text}")
            
            # Fallback: treat entire response as coach message
            coach_message = response_text
            internal_state = {
                "current_step": state["current_step"],
                "saturation_score": state["saturation_score"],
                "reflection": "Failed to parse structured output"
            }
            if not coach_message or not coach_message.strip():
                coach_message = get_next_step_question(state.get("current_step", "S1"), language)
        t6 = time.time()
        logger.info(f"[PERF] Parse JSON: {(t6-t5)*1000:.0f}ms")

        coach_message = _sanitize_coach_message(coach_message)
        
        # 5. Safety Net: Check for repeated questions
        t7 = time.time()
        history_for_check = get_conversation_history(state, last_n=10)
        repeated_check = check_repeated_question(coach_message, history_for_check, state['current_step'], language)
        t8 = time.time()
        logger.info(f"[PERF] Repeated check: {(t8-t7)*1000:.0f}ms")
        
        if repeated_check:
            overrides_applied.append("repetition")
            _bsd_log("REPETITION_OVERRIDE", original=coach_message[:80], replacement=repeated_check[:80],
                     step=state['current_step'])
            logger.warning(f"[Safety Net] Overriding repeated question")
            coach_message = repeated_check
            # Keep step conservative; mismatch/transition validators will decide advancement.
            internal_state["current_step"] = state["current_step"]
            internal_state["saturation_score"] = state.get("saturation_score", 0.3)
        
        # 5.5. Safety Net: Coach re-asking for event when user already gave it
        re_ask_check = detect_re_asking_for_event(coach_message, state, language)
        if re_ask_check:
            overrides_applied.append("re_ask_event")
            coach_message, next_step_for_reask = re_ask_check
            _bsd_log("RE_ASK_OVERRIDE", step=next_step_for_reask, reason="user_already_gave_event")
            internal_state["current_step"] = next_step_for_reask
            internal_state["saturation_score"] = 0.3
        
        # 6. Safety Net: Check for stage/question mismatch
        t9 = time.time()
        mismatch_stage = detect_stage_question_mismatch(coach_message, state["current_step"], language)
        t10 = time.time()
        logger.info(f"[PERF] Stage mismatch check: {(t10-t9)*1000:.0f}ms")
        
        if mismatch_stage:
            overrides_applied.append("stage_mismatch")
            _bsd_log("STAGE_MISMATCH", llm_step=internal_state.get("current_step"), corrected=mismatch_stage,
                     coach_preview=coach_message[:60])
            logger.warning(f"[Safety Net] Auto-correcting stage mismatch: {state['current_step']} â†’ {mismatch_stage}")
            internal_state["current_step"] = mismatch_stage
        
        # 6.5. Safety Net: Validate situation quality (S2â†’S3 only)
        old_step = state["current_step"]
        new_step = internal_state.get("current_step", old_step)
        
        t11 = time.time()
        if old_step == "S2" and new_step == "S3":
            # Check if situation meets all 4 criteria
            logger.info(f"[Safety Net] Validating S2 situation quality before S2â†’S3...")
            situation_valid, guidance = await validate_situation_quality(state, llm, language)
            logger.info(f"[Safety Net] Validation result: valid={situation_valid}")
            if not situation_valid and guidance:
                overrides_applied.append("s2_quality_block")
                _bsd_log("S2_QUALITY_BLOCK", reason="situation_not_meet_criteria")
                logger.warning(f"[Safety Net] Situation doesn't meet criteria, blocking S2â†’S3")
                coach_message = guidance
                internal_state["current_step"] = "S2"  # Stay in S2
        t12 = time.time()
        if old_step == "S2" and new_step == "S3":
            logger.info(f"[PERF] S2 validation: {(t12-t11)*1000:.0f}ms")
        
        # 7. Safety Net: Validate stage transition
        t13 = time.time()
        is_valid, correction = validate_stage_transition(old_step, new_step, state, language, coach_message)
        t14 = time.time()
        logger.info(f"[PERF] Stage transition validation: {(t14-t13)*1000:.0f}ms")
        if old_step != new_step:
            _bsd_log("TRANSITION_ATTEMPT", old_step=old_step, new_step=new_step, allowed=is_valid)

        if not is_valid and correction:
            overrides_applied.append("transition_block")
            _bsd_log("TRANSITION_BLOCK", old_step=old_step, new_step=new_step, reason=correction[:80])
            logger.warning(f"[Safety Net] Overriding transition {old_step}â†’{new_step}")
            coach_message = correction
            # Keep current step (don't advance)
            internal_state["current_step"] = old_step
        
        # 6b. Replace placeholder [× ×•×©×] in coach_message with actual topic
        topic_for_msg = (internal_state.get("collected_data") or {}).get("topic") or ""
        if topic_for_msg and ("[" in topic_for_msg or topic_for_msg.strip() in ("[× ×•×©×]", "[topic]")):
            topic_for_msg = ""
        if "[× ×•×©×]" in coach_message or "[topic]" in coach_message:
            replacement = topic_for_msg or (user_message[:50] + "..." if len(user_message) > 50 else user_message) if user_message else "×”× ×•×©×"
            coach_message = coach_message.replace("[× ×•×©×]", replacement).replace("[topic]", replacement)
        
        # 7. Update state
        logger.info(f"[BSD V2] Parsed coach_message: {coach_message[:100]}...")
        logger.info(f"[BSD V2] Parsed internal_state: {json.dumps(internal_state, ensure_ascii=False)[:200]}...")
        
        # Add user message
        state = add_message(state, "user", user_message)
        
        # Add coach message with internal state
        state = add_message(state, "coach", coach_message, internal_state)
        
        end_time = time.time()
        total_ms = (end_time - start_time) * 1000
        
        logger.info(f"[BSD V2] Updated to step: {state['current_step']}, saturation: {state['saturation_score']:.2f}")
        logger.info(f"[BSD V2] Total messages now: {len(state['messages'])}")
        logger.info(f"[PERF] â±ï¸  TOTAL TIME: {total_ms:.0f}ms ({total_ms/1000:.1f}s)")
        _bsd_log("TURN_END", final_step=state['current_step'], overrides=overrides_applied,
                 collected_data_keys=[k for k, v in state.get('collected_data', {}).items() if v])

        return coach_message, state
        
    except Exception as e:
        logger.error(f"[BSD V2] Error handling conversation: {e}")
        import traceback
        traceback.print_exc()

        # Graceful fallback for provider rate limiting
        err_text = str(e)
        if "RateLimitReached" in err_text or "Error code: 429" in err_text or "429" in err_text:
            if language == "he":
                return "×™×© ×›×¨×’×¢ ×¢×•××¡ ×¨×’×¢×™ ×‘××¢×¨×›×ª. × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×›××” ×©× ×™×•×ª ×•× ××©×™×š ×××•×ª×” × ×§×•×“×”.", state
            return "There is temporary load on the model right now. Please retry in a few seconds and we will continue from the same point.", state

        # Generic fallback
        if language == "he":
            fallback = "××¦×˜×¢×¨, ×”×™×ª×” ×‘×¢×™×” ×˜×›× ×™×ª. ×”×× × ×•×›×œ ×œ× ×¡×•×ª ×©×•×‘?"
        else:
            fallback = "Sorry, there was a technical issue. Can we try again?"

        return fallback, state
